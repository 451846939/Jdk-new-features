# 前言

因为英文不好大多数使用Google翻译进行，机翻有很多不合理的语句和翻译，望见谅

内容均来自openJDK与oracle的官方网站

# JSR

JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向[JCP](https://baike.baidu.com/item/JCP)(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。

## JCP

#### 简介

##### 定义

##### 技术规范

[Java](https://baike.baidu.com/item/Java/85979)技术规范、参考实现（RI）、技术兼容包（[TCK](https://baike.baidu.com/item/TCK/2903261)）。Java技术和JCP两者的原创者都是SUN计算机公司。然而，JCP已经由SUN于1995年创造Java的非正式过程，演进到如今有数百名来自世界各地Java代表成员一同监督Java发展的正式程序。



#### 规范组成

JCP维护的规范包括[J2ME](https://baike.baidu.com/item/J2ME)、[J2SE](https://baike.baidu.com/item/J2SE/2902733)、[J2EE](https://baike.baidu.com/item/J2EE/110838)，[XML](https://baike.baidu.com/item/XML)，OSS，[JAIN](https://baike.baidu.com/item/JAIN)等。组织成员可以提交[JSR](https://baike.baidu.com/item/JSR)（Java Specification Requests），通过特定程序以后，进入到下一版本的规范里面。

所有声称符合J2EE规范的J2EE类产品（应用服务器、应用软件、开发工具等），必须通过该组织提供的[TCK](https://baike.baidu.com/item/TCK/2903261)[兼容性测试](https://baike.baidu.com/item/兼容性测试)（需要购买测试包），通过该测试后，需要缴纳J2EE商标使用费。两项完成，即是通过J2EE认证（Authorized Java Licensees of J2EE）。

# JDK

## JDK9

> https://openjdk.java.net/projects/jdk9/

### 1.实现

JDK9 实现规范**jsr379**

> The official Reference Implementation for Java SE 9 ([JSR 379](https://www.jcp.org/en/jsr/detail?id=379)) is based solely upon open-source code available from the [JDK 9 Project](https://openjdk.java.net/projects/jdk9) in the [OpenJDK Community](https://openjdk.java.net/).
>
> https://www.jcp.org/en/jsr/detail?id=379

### 2.特征（Features）

https://openjdk.java.net/projects/jdk9/

> 102: [Process API Updates](https://openjdk.java.net/jeps/102)
> 110: [HTTP 2 Client](https://openjdk.java.net/jeps/110)
> 143: [Improve Contended Locking](https://openjdk.java.net/jeps/143)
> 158: [Unified JVM Logging](https://openjdk.java.net/jeps/158)
> 165: [Compiler Control](https://openjdk.java.net/jeps/165)
> 193: [Variable Handles](https://openjdk.java.net/jeps/193)
> 197: [Segmented Code Cache](https://openjdk.java.net/jeps/197)
> 199: [Smart Java Compilation, Phase Two](https://openjdk.java.net/jeps/199)
> 200: [The Modular JDK](https://openjdk.java.net/jeps/200)
> 201: [Modular Source Code](https://openjdk.java.net/jeps/201)
> 211: [Elide Deprecation Warnings on Import Statements](https://openjdk.java.net/jeps/211)
> 212: [Resolve Lint and Doclint Warnings](https://openjdk.java.net/jeps/212)
> 213: [Milling Project Coin](https://openjdk.java.net/jeps/213)
> 214: [Remove GC Combinations Deprecated in JDK 8](https://openjdk.java.net/jeps/214)
> 215: [Tiered Attribution for javac](https://openjdk.java.net/jeps/215)
> 216: [Process Import Statements Correctly](https://openjdk.java.net/jeps/216)
> 217: [Annotations Pipeline 2.0](https://openjdk.java.net/jeps/217)
> 219: [Datagram Transport Layer Security (DTLS)](https://openjdk.java.net/jeps/219)
> 220: [Modular Run-Time Images](https://openjdk.java.net/jeps/220)
> 221: [Simplified Doclet API](https://openjdk.java.net/jeps/221)
> 222: [jshell: The Java Shell (Read-Eval-Print Loop)](https://openjdk.java.net/jeps/222)
> 223: [New Version-String Scheme](https://openjdk.java.net/jeps/223)
> 224: [HTML5 Javadoc](https://openjdk.java.net/jeps/224)
> 225: [Javadoc Search](https://openjdk.java.net/jeps/225)
> 226: [UTF-8 Property Files](https://openjdk.java.net/jeps/226)
> 227: [Unicode 7.0](https://openjdk.java.net/jeps/227)
> 228: [Add More Diagnostic Commands](https://openjdk.java.net/jeps/228)
> 229: [Create PKCS12 Keystores by Default](https://openjdk.java.net/jeps/229)
> 231: [Remove Launch-Time JRE Version Selection](https://openjdk.java.net/jeps/231)
> 232: [Improve Secure Application Performance](https://openjdk.java.net/jeps/232)
> 233: [Generate Run-Time Compiler Tests Automatically](https://openjdk.java.net/jeps/233)
> 235: [Test Class-File Attributes Generated by javac](https://openjdk.java.net/jeps/235)
> 236: [Parser API for Nashorn](https://openjdk.java.net/jeps/236)
> 237: [Linux/AArch64 Port](https://openjdk.java.net/jeps/237)
> 238: [Multi-Release JAR Files](https://openjdk.java.net/jeps/238)
> 240: [Remove the JVM TI hprof Agent](https://openjdk.java.net/jeps/240)
> 241: [Remove the jhat Tool](https://openjdk.java.net/jeps/241)
> 243: [Java-Level JVM Compiler Interface](https://openjdk.java.net/jeps/243)
> 244: [TLS Application-Layer Protocol Negotiation Extension](https://openjdk.java.net/jeps/244)
> 245: [Validate JVM Command-Line Flag Arguments](https://openjdk.java.net/jeps/245)
> 246: [Leverage CPU Instructions for GHASH and RSA](https://openjdk.java.net/jeps/246)
> 247: [Compile for Older Platform Versions](https://openjdk.java.net/jeps/247)
> 248: [Make G1 the Default Garbage Collector](https://openjdk.java.net/jeps/248)
> 249: [OCSP Stapling for TLS](https://openjdk.java.net/jeps/249)
> 250: [Store Interned Strings in CDS Archives](https://openjdk.java.net/jeps/250)
> 251: [Multi-Resolution Images](https://openjdk.java.net/jeps/251)
> 252: [Use CLDR Locale Data by Default](https://openjdk.java.net/jeps/252)
> 253: [Prepare JavaFX UI Controls & CSS APIs for Modularization](https://openjdk.java.net/jeps/253)
> 254: [Compact Strings](https://openjdk.java.net/jeps/254)
> 255: [Merge Selected Xerces 2.11.0 Updates into JAXP](https://openjdk.java.net/jeps/255)
> 256: [BeanInfo Annotations](https://openjdk.java.net/jeps/256)
> 257: [Update JavaFX/Media to Newer Version of GStreamer](https://openjdk.java.net/jeps/257)
> 258: [HarfBuzz Font-Layout Engine](https://openjdk.java.net/jeps/258)
> 259: [Stack-Walking API](https://openjdk.java.net/jeps/259)
> 260: [Encapsulate Most Internal APIs](https://openjdk.java.net/jeps/260)
> 261: [Module System](https://openjdk.java.net/jeps/261)
> 262: [TIFF Image I/O](https://openjdk.java.net/jeps/262)
> 263: [HiDPI Graphics on Windows and Linux](https://openjdk.java.net/jeps/263)
> 264: [Platform Logging API and Service](https://openjdk.java.net/jeps/264)
> 265: [Marlin Graphics Renderer](https://openjdk.java.net/jeps/265)
> 266: [More Concurrency Updates](https://openjdk.java.net/jeps/266)
> 267: [Unicode 8.0](https://openjdk.java.net/jeps/267)
> 268: [XML Catalogs](https://openjdk.java.net/jeps/268)
> 269: [Convenience Factory Methods for Collections](https://openjdk.java.net/jeps/269)
> 270: [Reserved Stack Areas for Critical Sections](https://openjdk.java.net/jeps/270)
> 271: [Unified GC Logging](https://openjdk.java.net/jeps/271)
> 272: [Platform-Specific Desktop Features](https://openjdk.java.net/jeps/272)
> 273: [DRBG-Based SecureRandom Implementations](https://openjdk.java.net/jeps/273)
> 274: [Enhanced Method Handles](https://openjdk.java.net/jeps/274)
> 275: [Modular Java Application Packaging](https://openjdk.java.net/jeps/275)
> 276: [Dynamic Linking of Language-Defined Object Models](https://openjdk.java.net/jeps/276)
> 277: [Enhanced Deprecation](https://openjdk.java.net/jeps/277)
> 278: [Additional Tests for Humongous Objects in G1](https://openjdk.java.net/jeps/278)
> 279: [Improve Test-Failure Troubleshooting](https://openjdk.java.net/jeps/279)
> 280: [Indify String Concatenation](https://openjdk.java.net/jeps/280)
> 281: [HotSpot C++ Unit-Test Framework](https://openjdk.java.net/jeps/281)
> 282: [jlink: The Java Linker](https://openjdk.java.net/jeps/282)
> 283: [Enable GTK 3 on Linux](https://openjdk.java.net/jeps/283)
> 284: [New HotSpot Build System](https://openjdk.java.net/jeps/284)
> 285: [Spin-Wait Hints](https://openjdk.java.net/jeps/285)
> 287: [SHA-3 Hash Algorithms](https://openjdk.java.net/jeps/287)
> 288: [Disable SHA-1 Certificates](https://openjdk.java.net/jeps/288)
> 289: [Deprecate the Applet API](https://openjdk.java.net/jeps/289)
> 290: [Filter Incoming Serialization Data](https://openjdk.java.net/jeps/290)
> 291: [Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector](https://openjdk.java.net/jeps/291)
> 292: [Implement Selected ECMAScript 6 Features in Nashorn](https://openjdk.java.net/jeps/292)
> 294: [Linux/s390x Port](https://openjdk.java.net/jeps/294)
> 295: [Ahead-of-Time Compilation](https://openjdk.java.net/jeps/295)
> 297: [Unified arm32/arm64 Port](https://openjdk.java.net/jeps/297)
> 298: [Remove Demos and Samples](https://openjdk.java.net/jeps/298)
> 299: [Reorganize Documentation](https://openjdk.java.net/jeps/299)

102：[处理API更新](https://openjdk.java.net/jeps/102)
110：[HTTP 2客户端](https://openjdk.java.net/jeps/110)
143：[改进竞争锁定](https://openjdk.java.net/jeps/143)
158：[统一JVM记录](https://openjdk.java.net/jeps/158)
165：[编译器控制](https://openjdk.java.net/jeps/165)
193：[可变句柄](https://openjdk.java.net/jeps/193)
197：[分段代码高速缓存](https://openjdk.java.net/jeps/197)
199：[智能Java编译，阶段二](https://openjdk.java.net/jeps/199)
200：[模块化JDK](https://openjdk.java.net/jeps/200)
201：[模块化源代码](https://openjdk.java.net/jeps/201)
211：[导入语句的](https://openjdk.java.net/jeps/211)[Elide ](https://openjdk.java.net/jeps/212)[弃用警告](https://openjdk.java.net/jeps/211)
212：[解决Lint和Doclint警告](https://openjdk.java.net/jeps/212)
213：[铣削项目硬币](https://openjdk.java.net/jeps/213)
214：[删除GC组合JDK 8中不推荐使用](https://openjdk.java.net/jeps/214)
215：[javac的分层归因](https://openjdk.java.net/jeps/215)
216：[正确处理导入语句](https://openjdk.java.net/jeps/216)
217：[注释管道2.0](https://openjdk.java.net/jeps/217)
219：[数据报传输层安全性（DTLS）](https://openjdk.java.net/jeps/219)
220：[模块化运行时图像](https://openjdk.java.net/jeps/220)
221：[简化的Doclet API](https://openjdk.java.net/jeps/221)
222：[jshell：Java Shell（读取 - 评估 - 打印循环）](https://openjdk.java.net/jeps/222)
223：[新的Version-String Scheme](https://openjdk.java.net/jeps/223)
224：[HTML5 Javadoc](https://openjdk.java.net/jeps/224)
225：[Javadoc Search](https://openjdk.java.net/jeps/225)
226：[UTF-8属性文件](https://openjdk.java.net/jeps/226)
227：[Unicode 7.0](https://openjdk.java.net/jeps/227)
228：[添加更多诊断命令](https://openjdk.java.net/jeps/228)
229：[默认创建PKCS12密钥库](https://openjdk.java.net/jeps/229)
231：[删除启动时JRE版本选择](https://openjdk.java.net/jeps/231)
232：[提高安全应用程序性能](https://openjdk.java.net/jeps/232)
233：[自动生成运行时编译器测试](https://openjdk.java.net/jeps/233)
235：[测试类文件属性由javac生成](https://openjdk.java.net/jeps/235)
236：[Nashorn的解析器API](https://openjdk.java.net/jeps/236)
237：[Linux / AArch64端口](https://openjdk.java.net/jeps/237)
238：[多版本JAR文件](https://openjdk.java.net/jeps/238)
240：[删除JVM TI hprof代理](https://openjdk.java.net/jeps/240)
241：[删除jhat工具](https://openjdk.java.net/jeps/241)
243：[Java级JVM编译器接口](https://openjdk.java.net/jeps/243)
244：[TLS应用层协议协商扩展](https://openjdk.java.net/jeps/244)
245：[验证JVM命令行标志参数](https://openjdk.java.net/jeps/245)
246：[利用GHASH和RSA的CPU指令](https://openjdk.java.net/jeps/246)
247：[编译较旧的平台版本](https://openjdk.java.net/jeps/247)
248：[使G1成为默认垃圾收集器](https://openjdk.java.net/jeps/248)
249：[针对TLS](https://openjdk.java.net/jeps/249)的[OCSP装订](https://openjdk.java.net/jeps/249)
250：[在CDS存档中存储间隔字符串](https://openjdk.java.net/jeps/250)
251：[多分辨率图像](https://openjdk.java.net/jeps/251)
252：[默认使用CLDR区域设置数据](https://openjdk.java.net/jeps/252)
253：[为模块化准备JavaFX UI控件和CSS API](https://openjdk.java.net/jeps/253)
254：[紧凑字符串](https://openjdk.java.net/jeps/254)
255 ：[选定的Xerces 2.11.0更新合并到JAXP](https://openjdk.java.net/jeps/255)
256：[BeanInfo注释](https://openjdk.java.net/jeps/256)
257：[JavaFX / Media更新到更新版本的GStreamer](https://openjdk.java.net/jeps/257)
258：[HarfBuzzFonts-Layout Engine](https://openjdk.java.net/jeps/258)
259：[Stack-Walking API](https://openjdk.java.net/jeps/259)
260：[封装大多数内部API](https://openjdk.java.net/jeps/260)
261：[模块系统](https://openjdk.java.net/jeps/261)
262：[TIFF图像I / O](https://openjdk.java.net/jeps/262)
263：[Windows和Linux上的HiDPI图形](https://openjdk.java.net/jeps/263)
264：[平台记录API和服务](https://openjdk.java.net/jeps/264)
265：[Marlin图形渲染器](https://openjdk.java.net/jeps/265)
266：[更多并发更新](https://openjdk.java.net/jeps/266)
267：[Unicode 8.0](https://openjdk.java.net/jeps/267)
268：[XML目录](https://openjdk.java.net/jeps/268)
269：[集合的便利工厂方法](https://openjdk.java.net/jeps/269)
270：[保留关键部分的堆栈区域](https://openjdk.java.net/jeps/270)
271：[统一GC记录](https://openjdk.java.net/jeps/271)
272：[特定于平台的桌面功能](https://openjdk.java.net/jeps/272)
273：[基于DRBG的SecureRandom实现](https://openjdk.java.net/jeps/273)
274：[增强的方法句柄](https://openjdk.java.net/jeps/274)
275：[模块化Java应用程序打包](https://openjdk.java.net/jeps/275)
276：[语言定义的对象模型的动态链接](https://openjdk.java.net/jeps/276)
277：[增强的弃使](https://openjdk.java.net/jeps/277)
278：[G1](https://openjdk.java.net/jeps/278)中的[对象中的附加测试](https://openjdk.java.net/jeps/278)
279：[改进测试失败故障排除](https://openjdk.java.net/jeps/279)
280：[表示字符串连接](https://openjdk.java.net/jeps/280)
281：[HotSpot C ++单元测试框架](https://openjdk.java.net/jeps/281)
282：[jlink：Java链接器](https://openjdk.java.net/jeps/282)
283：[在Linux上启用GTK 3](https://openjdk.java.net/jeps/283)
284：[新的HotSpot构建系统](https://openjdk.java.net/jeps/284)
285：[旋转等待提示](https://openjdk.java.net/jeps/285)
287：[SHA-3哈希算法](https://openjdk.java.net/jeps/287)
288：[禁用SHA-1证书](https://openjdk.java.net/jeps/288)
289：[弃用Applet API](https://openjdk.java.net/jeps/289)
290：[过滤传入的序列化数据](https://openjdk.java.net/jeps/290)
291：[弃用并发标记扫描（CMS）垃圾收集器](https://openjdk.java.net/jeps/291)
292：[在Nashorn中实现选定的ECMAScript 6功能](https://openjdk.java.net/jeps/292)
294：[Linux / s390x端口](https://openjdk.java.net/jeps/294)
295：[提前编译](https://openjdk.java.net/jeps/295)
297：[统一arm32 / arm64端口](https://openjdk.java.net/jeps/297)
298：[删除演示和示例](https://openjdk.java.net/jeps/298)
299：[重新组织文档](https://openjdk.java.net/jeps/299)

这里重点说G1和模块化

#### 2.1模块化

##### 	2.1.1 idea模块

java程序员最目前最常见，使用最多的idea工程结构就是以模块为主，一个project下面都是module

<img src="https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568947439883.png" alt="1568947439883" style="zoom:100%;" />

##### 	2.1.2 mavn/gradle模块化 

使用maven/gradle对项目模块化，这里以alibaba的jvm.sandbox以例

<img src="https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568947657176.png" alt="1568947657176" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568947627882.png" alt="1568947627882" style="zoom: 80%;" />

项目主pom中的modules

``` xml
    <modules>
        <module>sandbox-agent</module>
        <module>sandbox-core</module>
        <module>sandbox-api</module>
        <module>sandbox-spy</module>
        <module>sandbox-mgr-module</module>
        <module>sandbox-provider-api</module>
        <module>sandbox-common-api</module>
        <module>sandbox-mgr-provider</module>
        <module>sandbox-module-starter</module>
        <module>sandbox-debug-module</module>
    </modules>
```

##### 2.1.3 java9模块化

> http://openjdk.java.net/jeps/261
>
> http://openjdk.java.net/projects/jigsaw/quick-start#greetingsworld

###### 2.1.3.1 什么是模块化

模块是代码和数据集合，它可以包含Java代码和本地代码。

对于Java代码，模块可以看做零个或多个包的集合。除了其名称，模块定义包括以下内容：

- requires其他模块（或依赖于）的列表
- exports包列表（其public API），其他模块可以使用
- open的包（整个API，共有和私有），其他模块可以反射调用
- 使用的服务列表
- 提供的服务的实现列表

![1568964483958](https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568964483958.png)

以下面java9以后的jdk目录为例，9以后不再存在rt.jar，java自己使用模块化重构了java

<img src="https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568961689020.png" alt="1568961689020" style="zoom: 80%;" />

###### 2.1.3.2 编写模块

那么我们自己如何编写java9以后的模块呢

![1568961753146](https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568961753146.png)

首先module-info.java非常重要且只可以存在sourceroot中也就是src下

编译后如下图

![1568961865479](https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568961865479.png)

modules 的`module-info.java`

~~~java
module modules {
    exports modules.module1;
    exports modules.module2;
}
~~~

test的`module-info.java`

~~~java
module test {
    requires modules;
}
~~~

这是最简单的一个test引用modules模块

###### 2.1.3.3 模块化语法

~~~java
[open] module <moduleName> {

　　<module-statement>;

　　......

}
~~~

- 导出语句（exports），导出模块，其他模块访问。

- 开放语句（opens），开放当前模块，其他模块可以访问，包括反射调用等。

- 需要语句（requires），声明模块对另一个模块的依赖关系。

- 使用语句（uses），表达服务消费。

- 提供语句（provides），表达服务提供。

  **exports**

  导出语句将模块的指定包导出到所有模块或编译时和运行时的命令模块列表。形式如下：

  exports <package>;

  假设需要开发多个模块组成的库或框架，其中有一个模块中的包含API，仅供某些模块内部使用。也就是说，该模块中的包不需要导出到所有模块，而是其可访问性必须限于几个命名的模块，可以使用模块声明中的限定的export to语句来实现：

  exports <package> to <module1>, <module2>;

  package：当前模块要导出的包的名称；

  module1,module2……：可以读取当前模块的模块的名称。

  **opens**

  Java允许使用反射机制访问所有成员，包括私有，公共，包和受保护的类型。需要在成员对象上调用setAccessible(true)方法。

  模块系统提供如下规则：

  - exports的包将允许在编译和运行时访问public类型及其public成员，如果不exports包，则该包中的所有类型都不可访问其他模块；
- 可以打开一个模块，以便在运行时对该模块中的所有包中的所有类型进行深层反射，这样的模块称为开放模块；
  

开放语句允许对所有模块的反射访问指定的包或运行时指定的模块列表。其他模块可以反射访问指定包中的所有类型以及这些类型的所有成员（私有和公共），开放语句采用如下形式：

opens <package>;

opens <package> to <module1>, <module2>;

**声明依赖关系**

  模块系统在编译时以及运行时验证模块的依赖关系，有事希望在编译时模块依赖性是必需的，但在运行时是可选的。 

  需要（require）语句声明当前模块对另一个模块的依赖关系，

  requires <module>;

  requires transitive <module>;

  requires static <module>;

  requires transitive static <module>;

  static标示在编译时的依赖是强制的，但在运行时是可选的：requires static N意味着模块M需要模块N，模块N必须在编译时出现才能编译模块M，而在运行时存在模块N是可选的。

  transitive当前模块依赖其他模块具有隐式依赖性，假设有三个模块P,Q和R，假设模块Q包含requires transitive R语句，如果模块P包含requires Q，这意味着模块P隐含依赖模块R。

**配置服务**

  使用与spi结合

  Java允许使用服务提供者和服务使用者分离的服务提供者机制。JDK9运行使用语句uses和provides实现其服务。

  use语句可以指定服务接口的名字，当前模块就会发现它，使用java.util.ServiceLoader类进行加载：

  uses <service-interface>

  provide语句指定服务接口的一个或多个服务厅程序实现类：

  provide <service-interface> with <service-impl-class1>, <service-impl-class2>;

关于`module-inf.java`的具体写法可以参考官方文档以及jdk的写法

这里给出java.base下的`module-info.java`

~~~java
module java.base {
    // source file: file:///t:/workspace/open/src/java.base/share/classes/module-info.java
    //              file:///t:/workspace/open/src/java.base/windows/classes/module-info.java.extra
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.constant;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    exports java.net.spi;
    exports java.nio;
    exports java.nio.channels;
    exports java.nio.channels.spi;
    exports java.nio.charset;
    exports java.nio.charset.spi;
    exports java.nio.file;
    exports java.nio.file.attribute;
    exports java.nio.file.spi;
    exports java.security;
    exports java.security.acl;
    exports java.security.cert;
    exports java.security.interfaces;
    exports java.security.spec;
    exports java.text;
    exports java.text.spi;
    exports java.time;
    exports java.time.chrono;
    exports java.time.format;
    exports java.time.temporal;
    exports java.time.zone;
    exports java.util;
    exports java.util.concurrent;
    exports java.util.concurrent.atomic;
    exports java.util.concurrent.locks;
    exports java.util.function;
    exports java.util.jar;
    exports java.util.regex;
    exports java.util.spi;
    exports java.util.stream;
    exports java.util.zip;
    exports javax.crypto;
    exports javax.crypto.interfaces;
    exports javax.crypto.spec;
    exports javax.net;
    exports javax.net.ssl;
    exports javax.security.auth;
    exports javax.security.auth.callback;
    exports javax.security.auth.login;
    exports javax.security.auth.spi;
    exports javax.security.auth.x500;
    exports javax.security.cert;
    exports com.sun.security.ntlm to java.security.sasl;
    exports jdk.internal to jdk.jfr;
    exports jdk.internal.access to
        java.desktop,
        java.logging,
        java.management,
        java.naming,
        java.rmi,
        jdk.jlink,
        jdk.net;
    exports jdk.internal.event to jdk.jfr;
    exports jdk.internal.jimage to jdk.jlink;
    exports jdk.internal.jimage.decompressor to jdk.jlink;
    exports jdk.internal.jmod to
        jdk.compiler,
        jdk.jlink;
    exports jdk.internal.loader to
        java.instrument,
        java.logging;
    exports jdk.internal.logger to java.logging;
    exports jdk.internal.misc to
        java.desktop,
        java.logging,
        java.management,
        java.naming,
        java.net.http,
        java.rmi,
        java.security.jgss,
        java.xml,
        jdk.attach,
        jdk.charsets,
        jdk.compiler,
        jdk.internal.vm.ci,
        jdk.jfr,
        jdk.jshell,
        jdk.scripting.nashorn,
        jdk.scripting.nashorn.shell,
        jdk.unsupported;
    exports jdk.internal.module to
        java.instrument,
        java.management.rmi,
        jdk.jartool,
        jdk.jfr,
        jdk.jlink;
    exports jdk.internal.org.objectweb.asm to
        jdk.jartool,
        jdk.jfr,
        jdk.jlink,
        jdk.scripting.nashorn;
    exports jdk.internal.org.objectweb.asm.commons to
        jdk.jfr,
        jdk.scripting.nashorn;
    exports jdk.internal.org.objectweb.asm.signature to jdk.scripting.nashorn;
    exports jdk.internal.org.objectweb.asm.tree to
        jdk.jfr,
        jdk.jlink;
    exports jdk.internal.org.objectweb.asm.util to
        jdk.jfr,
        jdk.scripting.nashorn;
    exports jdk.internal.org.xml.sax to jdk.jfr;
    exports jdk.internal.org.xml.sax.helpers to jdk.jfr;
    exports jdk.internal.perf to
        java.management,
        jdk.internal.jvmstat,
        jdk.management.agent;
    exports jdk.internal.ref to java.desktop;
    exports jdk.internal.reflect to
        java.logging,
        java.sql,
        java.sql.rowset,
        jdk.dynalink,
        jdk.internal.vm.ci,
        jdk.scripting.nashorn,
        jdk.unsupported;
    exports jdk.internal.util.jar to jdk.jartool;
    exports jdk.internal.util.xml to jdk.jfr;
    exports jdk.internal.util.xml.impl to jdk.jfr;
    exports jdk.internal.vm to
        jdk.internal.jvmstat,
        jdk.management.agent;
    exports jdk.internal.vm.annotation to
        jdk.internal.vm.ci,
        jdk.unsupported;
    exports sun.net to
        java.net.http,
        jdk.naming.dns;
    exports sun.net.dns to
        java.security.jgss,
        jdk.naming.dns;
    exports sun.net.ext to jdk.net;
    exports sun.net.util to
        java.desktop,
        java.net.http,
        jdk.jconsole;
    exports sun.net.www to
        java.net.http,
        jdk.jartool;
    exports sun.net.www.protocol.http to java.security.jgss;
    exports sun.nio.ch to
        java.management,
        jdk.crypto.cryptoki,
        jdk.net,
        jdk.sctp;
    exports sun.nio.cs to jdk.charsets;
    exports sun.reflect.annotation to jdk.compiler;
    exports sun.reflect.generics.reflectiveObjects to java.desktop;
    exports sun.reflect.misc to
        java.datatransfer,
        java.desktop,
        java.management,
        java.management.rmi,
        java.rmi,
        java.sql.rowset;
    exports sun.security.action to
        java.desktop,
        java.security.jgss;
    exports sun.security.internal.interfaces to jdk.crypto.cryptoki;
    exports sun.security.internal.spec to
        jdk.crypto.cryptoki,
        jdk.crypto.mscapi;
    exports sun.security.jca to
        java.smartcardio,
        jdk.crypto.cryptoki,
        jdk.crypto.ec,
        jdk.naming.dns;
    exports sun.security.pkcs to
        jdk.crypto.ec,
        jdk.jartool;
    exports sun.security.provider to
        java.rmi,
        java.security.jgss,
        jdk.crypto.cryptoki,
        jdk.security.auth;
    exports sun.security.provider.certpath to java.naming;
    exports sun.security.rsa to
        jdk.crypto.cryptoki,
        jdk.crypto.mscapi;
    exports sun.security.timestamp to jdk.jartool;
    exports sun.security.tools to jdk.jartool;
    exports sun.security.util to
        java.desktop,
        java.naming,
        java.rmi,
        java.security.jgss,
        java.security.sasl,
        java.smartcardio,
        java.xml.crypto,
        jdk.crypto.cryptoki,
        jdk.crypto.ec,
        jdk.crypto.mscapi,
        jdk.jartool,
        jdk.security.auth,
        jdk.security.jgss;
    exports sun.security.util.math to jdk.crypto.ec;
    exports sun.security.util.math.intpoly to jdk.crypto.ec;
    exports sun.security.validator to jdk.jartool;
    exports sun.security.x509 to
        jdk.crypto.cryptoki,
        jdk.crypto.ec,
        jdk.jartool;
    exports sun.util.cldr to jdk.jlink;
    exports sun.util.locale.provider to
        java.desktop,
        jdk.jlink,
        jdk.localedata;
    exports sun.util.logging to
        java.desktop,
        java.logging,
        java.prefs;
    exports sun.util.resources to jdk.localedata;

    uses java.lang.System.LoggerFinder;
    uses java.net.ContentHandlerFactory;
    uses java.net.spi.URLStreamHandlerProvider;
    uses java.nio.channels.spi.AsynchronousChannelProvider;
    uses java.nio.channels.spi.SelectorProvider;
    uses java.nio.charset.spi.CharsetProvider;
    uses java.nio.file.spi.FileSystemProvider;
    uses java.nio.file.spi.FileTypeDetector;
    uses java.security.Provider;
    uses java.text.spi.BreakIteratorProvider;
    uses java.text.spi.CollatorProvider;
    uses java.text.spi.DateFormatProvider;
    uses java.text.spi.DateFormatSymbolsProvider;
    uses java.text.spi.DecimalFormatSymbolsProvider;
    uses java.text.spi.NumberFormatProvider;
    uses java.time.chrono.AbstractChronology;
    uses java.time.chrono.Chronology;
    uses java.time.zone.ZoneRulesProvider;
    uses java.util.spi.CalendarDataProvider;
    uses java.util.spi.CalendarNameProvider;
    uses java.util.spi.CurrencyNameProvider;
    uses java.util.spi.LocaleNameProvider;
    uses java.util.spi.ResourceBundleControlProvider;
    uses java.util.spi.ResourceBundleProvider;
    uses java.util.spi.TimeZoneNameProvider;
    uses java.util.spi.ToolProvider;
    uses javax.security.auth.spi.LoginModule;
    uses jdk.internal.logger.DefaultLoggerFinder;
    uses sun.text.spi.JavaTimeDateTimePatternProvider;
    uses sun.util.locale.provider.LocaleDataMetaInfo;
    uses sun.util.resources.LocaleData.CommonResourceBundleProvider;
    uses sun.util.resources.LocaleData.SupplementaryResourceBundleProvider;
    uses sun.util.spi.CalendarProvider;
    provides java.nio.file.spi.FileSystemProvider with 	        jdk.internal.jrtfs.JrtFileSystemProvider;
}
~~~

这里给出相关的模块化文档链接

> http://openjdk.java.net/projects/jigsaw/quick-start#greetingsworld
>
> http://openjdk.java.net/jeps/261
>
> http://openjdk.java.net/projects/jigsaw/spec/sotms/

###### 2.1.3.4 模块的类型

​	旧的和新的应用程序将继续使用未被模块化或永远不会被模块化的库，如果JDK9保持向后兼容性。在大多数情况下，在JDK8或更早版本中工作的应用程序将继续在JDK 9中工作，为了简化迁移，JDK9定义了4中类型的模块：

- 普通模块（Normal Modules）

- 开放模块（Open Modules）

- 自动模块（Automatic Modules）

- 未命名模块（Unnameed Modules）

  ![1568964423297](https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/1568964423297.png)

  （1）一个模块是代码和数据的集合；

  （2）基于模块是否具有名称，模块可以是命名模块或未命名模块；

  （3）没有其他类别的未命名模块；

  （4）当模块具有名称时，可以在模块声明中明确指定名称，或则可以自动（或隐式）生成名称，如果名称在模块声明中明确指定，则称为显式模块，如果名称由模块系统通过读取模块路径上的JAR文件名生成，则称为自动模块。

  （5）如果不实用open修饰符的情况下声明模块，则称为普通模块；

  （6）如果使用open修饰符声明模块，则称为开放模块。

  开放模块也是显式模块和命名模块，自动模块是一个命名模块，因为它具有自动生成的名称，但它不是显式模块，因为它在模块系统在编译时和运行时被隐式声明。

  **普通模块**

  使用模块声明明确而不实用open修饰符的模块始终被赋予一个名称，它被称为普通模块或简化模块。
  
  **开放模块**
  
  模块声明包含open修饰符，则该模块被称为开放模块。
  
  **自动模块 **
  
  为了向后兼容，查找类型的类路径机制仍然可以在JDK9中使用，可以选择将JAR放在类路径、模块路径和两者组合上。请注意，可以在模块路径和类路径上放置模块化JAR以及JAR。
  
  **将JAR放在模块路径上时，JAR被视为一个模块，称为自动模块。**
  
  自动模块其实也是一个有名字的模块，其名称和版本由JAR文件的名称派生，规则如下：
  
  - 删除jAR文件的.jar扩展名，如果JAR文件名是com.jdk9.m-1.0.jar，则此步骤将删除.jar扩展名，并通过以下步骤使用com.jdk9.m-1.0来推倒出模块的名称及其版本；
  
  - 如果名称以连字符后跟至少一个数字（也可后跟一个点），则模块名称将从最后一个连字符之前的名称部分派生，如果它可以被解析为有效的版本，连字符后面的部分被分配为模块的版本，在此示例中，模块名称将从com.jdk9.m派生，版本派生为1.0；
  
  - 名称部分中的每个非字母数字字符都被替换为一个点，并且在所得到的字符串中，用一个点替换两个连续的点，此外，所有前导和后跟的点都被删除。
  
    | **JAR名词**                   | **模块名称** |
    | ----------------------------- | ------------ |
    | junit-4.10                    | junit        |
    | apache-logging1.5.0           | 有错误       |
    | spring-core-4.0.1.RELEASE     | spring.core  |
    | jdojo-tans-api_1.5_spec-1.0.0 | 有错误       |
    | -                             | 有错误       |
  
    如果无法从其名称导出有效的自动模块名称，则放置在模块路径上的JAR将抛出异常：
    java.lang.module.ResolutionException: Unable to derive module desciptor for: apache-logging1.5.0.jar
  
    要有效使用的自动模块，必须导出包并读取其他模块：
  
    - 自动模块读取所有其他 模块，在解析模块图之后，会添加自动OK到所有其他模块，其他模块都可以读取自动模块；
  
    - 自动模块中的所有包都被导出并打开
  
  **未命名模块**
  
  可以将JAR和模块化JAR放在类路径上，当类型加载并且在任何已知模块中到不到其包时，模块系统会尝试从类路径加载类型。如果在类型路径上找到该类型，它将由类加载器加载，并成为该类加载器的一个名为unnamed模块的模块成员。每个类加载器定义一个未命名的模块，其成员是从类路径加载的所有类型。一个未命名的模块没有名次，因此显式模块不能使用requires语句来声明对它的依赖，如果有明确的模块需要时会用未命名模块中的类型，则必须通过将JAR放置在模块路径上，将未命名模块的JAR用作自动模块。
  
#### 2.4 类加载器

##### 2.3.1 ClassLoader

Java SE Platform API历史上指定了两个类加载器： *引导类加载器*，它从引导类路径加载类(*bootstrap class loader*)，以及[*系统类加载器*](http://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getSystemClassLoader--)( [*system class loader*](http://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getSystemClassLoader--))，它是新类加载器的默认委托父类，通常是用于加载的类加载器。加载并启动应用程序。该规范并未强制要求这些类加载器的具体类型，也不强制它们的精确委托关系。

自1.2发布以来，JDK实现了类级加载器的三级层次结构，其中每个加载器委托给下一个：

- 应用程序类加载器(*application class loader*)是一个实例 `java.net.URLClassLoader`，它从类路径加载类，并作为系统类加载器安装，除非通过系统属性指定了备用系统加载程序 `java.system.class.loader`。
- 扩展类加载器(*extension class loader*)也是一个实例`URLClassLoader`，它通过[扩展机制](http://docs.oracle.com/javase/8/docs/technotes/guides/extensions/index.html)加载可用的类，还有一些内置于JDK的资源和服务提供者。（Java SE平台API规范中未明确提及此加载程序。）
- 引导类加载器(*bootstrap class loader*)，它是在虚拟机中单独实现，并且由下式表示`null`的在`ClassLoader` API，从引导类路径加载的类。

JDK 9保留这个三级层次结构，以保持兼容性，同时进行以下更改以实现模块系统：

- 应用程序类加载器(*application class loader*)不再`URLClassLoader`是内部类的实例，而是内部类的实例 。它是命名模块的默认加载器，既不是Java SE也不是JDK模块。
- 扩展类加载器(*extension class loader*)不再`URLClassLoader`是内部类的实例，而是内部类的实例 。它不再通过[JEP 220](http://openjdk.java.net/jeps/220)删除的扩展机制加载类 。但是，它确实定义了选定的Java SE和JDK模块，下面将详细介绍。在它的新角色中，这个加载器被称为*平台类加载器*(*platform class loader*)，它可以通过新 `ClassLoader::getPlatformClassLoader` [方法获得](http://download.java.net/java/jdk9/docs/api/java/lang/ClassLoader.html#getPlatformClassLoader--)，它将是Java SE Platform API Specification所要求的。
- 引导类加载器(*bootstrap class loader*)在库代码和虚拟机中实现，但为了兼容性，它仍然`null`在`ClassLoader`API中表示。它定义了核心Java SE和JDK模块。

保留平台类加载器(*platform class loader*)不仅是为了兼容性，而且还为了提高安全性。引导类加载器加载(*bootstrap class loader*)的类型被隐式授予所有安全权限（`AllPermission`），但其中许多类型实际上并不需要所有权限。我们 通过将它们定义到平台加载器(*platform class loader*)而不是引导类加载器(*bootstrap class loader*)，并通过向它们授予它们在默认安全策略文件中实际需要的权限，来*取消*不需要所有权限*的特权*模块。定义到平台类加载器的Java SE和JDK模块是：

```
java.activation*            jdk.accessibility
java.compiler*              jdk.charsets
java.corba*                 jdk.crypto.cryptoki
java.scripting              jdk.crypto.ec
java.se                     jdk.dynalink
java.se.ee                  jdk.incubator.httpclient
java.security.jgss          jdk.internal.vm.compiler*
java.smartcardio            jdk.jsobject
java.sql                    jdk.localedata
java.sql.rowset             jdk.naming.dns
java.transaction*           jdk.scripting.nashorn
java.xml.bind*              jdk.security.auth
java.xml.crypto             jdk.security.jgss
java.xml.ws*                jdk.xml.dom
java.xml.ws.annotation*     jdk.zipfs
```

（星号，`'*'`在这些列表中表示可升级的模块。）

提供工具或导出工具API的JDK模块定义到应用程序类加载器：

```
jdk.aot                     jdk.jdeps
jdk.attach                  jdk.jdi
jdk.compiler                jdk.jdwp.agent
jdk.editpad                 jdk.jlink
jdk.hotspot.agent           jdk.jshell
jdk.internal.ed             jdk.jstatd
jdk.internal.jvmstat        jdk.pack
jdk.internal.le             jdk.policytool
jdk.internal.opt            jdk.rmic
jdk.jartool                 jdk.scripting.nashorn.shell
jdk.javadoc                 jdk.xml.bind*
jdk.jcmd                    jdk.xml.ws*
jdk.jconsole
```

所有其他Java SE和JDK模块都定义到引导类加载器：

```
java.base                   java.security.sasl
java.datatransfer           java.xml
java.desktop                jdk.httpserver
java.instrument             jdk.internal.vm.ci
java.logging                jdk.management
java.management             jdk.management.agent
java.management.rmi         jdk.naming.rmi
java.naming                 jdk.net
java.prefs                  jdk.sctp
java.rmi                    jdk.unsupported
```

三个内置类加载器一起工作以加载类，如下所示：

- 应用程序类加载器(*application class loader*)首先搜索定义到所有内置加载器的命名模块。如果为这些加载器之一定义了合适的模块，则该加载器将加载该类。如果在为其中一个加载器定义的命名模块中找不到类，则应用程序类加载器将委托给其父级。如果其父级未找到类，则应用程序类装入器将搜索类路径。在类路径中找到的类作为此加载器的未命名模块的成员加载。
- 平台类加载器(*platform class loader*)搜索定义到所有内置加载器的命名模块。如果为这些加载器之一定义了合适的模块，则该加载器将加载该类。（因此，平台类加载器现在可以委托给应用程序类加载器，当升级模块路径上的模块依赖于应用程序模块路径上的模块时，这可能很有用。）如果在命名模块中找不到类定义到这些加载器之一，然后平台类加载器委托给它的父。
- 引导类加载器(*bootstrap class loader*)搜索定义到自身的命名模块。如果在为引导加载程序定义的命名模块中找不到类，则引导类加载器将通过该`-Xbootclasspath/a`选项搜索添加到引导程序类路径的文件和目录 。在引导程序类路径中找到的类作为此加载程序的未命名模块的成员加载。

应用程序和平台类加载器委托给它们各自的父加载器，以确保在为其中一个内置加载器定义的模块中找不到类时仍然搜索引导类路径。

  ##### 2.3.2 删除：Bootstrap类路径选项(Bootstrap class-path options)

在早期版本中，该`-Xbootclasspath`选项允许覆盖默认引导类路径，该`-Xbootclasspath/p`选项允许将一系列文件和目录添加到默认路径。通过JDK特定的系统属性报告此路径的计算值`sun.boot.class.path`。

在模块系统就位的情况下，默认情况下引导类路径为空，因为引导类是从它们各自的模块加载的。该`javac`编译器只支持`-Xbootclasspath`在传统模式选项，`java`启动不再支持这些选项，并且将系统属性`sun.boot.class.path`已被删除。

编译器的`--system`选项可用于指定系统模块的备用源，如上所述，其`-release`选项可用于指定备用平台版本，如 [JEP 247（编译旧版平台版本）中所述](http://openjdk.java.net/jeps/247)。在运行时`--patch-module`，上面提到的 选项可用于将内容注入初始模块图中的模块。

相关选项`-Xbootclasspath/a`允许将文件和目录附加到默认引导程序类路径。此选项以及`java.lang.instrument`程序包中的相关API 有时由检测代理程序使用，因此为了兼容性，它在运行时仍受支持。如果指定，则通过JDK特定的系统属性报告其值`jdk.boot.class.path.append`。此选项可以传递给命令行启动程序，也可以传递给`java`JNI调用API。

#### 2.3 G1

> https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42

##### 2.2.1 什么是G1

Garbage-First（G1）垃圾收集器的目标是具有大量内存的多处理器机器。它试图以高概率满足垃圾收集暂停时间目标，同时在几乎不需要配置的情况下实现高吞吐量。G1旨在使用当前目标应用程序和环境提供延迟和吞吐量之间的最佳平衡，其功能包括：

- 堆大小最多为10 GB或更大，超过50％的Java堆占用实时数据。
- 对象分配和促销的比率随时间变化很大。
- 堆中存在大量碎片。
- 可预测的暂停时间目标目标，不超过几百毫秒，避免长时间的垃圾收集暂停。

G1取代了Concurrent Mark-Sweep（CMS）收集器。它也是默认的收集器。

##### 2.2.2 启动G1

Garbage-First垃圾收集器是默认收集器，因此通常您不必执行任何其他操作。您可以通过`-XX:+UseG1GC`在命令行上提供来明确启用它。

##### 2.2.3 基本概念

G1是世代的，增量的，并行的，大多数并发的，停止世界的，疏散的垃圾收集器，它监视每个世界上停顿的暂停时间目标。与其他垃圾回收类似，G1将堆分成（虚拟）年轻和老一代。空间回收工作集中在年轻一代，这是最有效的，老一代偶尔进行空间回收

有些操作总是在世界各地暂停时执行以提高吞吐量。其他需要花费更多时间停止应用程序的操作，例如*全局标记*等整堆操作，是与应用程序并行执行的。为了避免空间回收的世界停顿，G1逐步并行地逐步进行空间回收。G1通过跟踪有关先前应用程序行为和垃圾收集暂停的信息来建立相关成本模型，从而实现可预测性。它使用此信息来确定暂停中完成的工作的大小。例如，G1首先在最有效的区域中回收空间（即大多数区域充满垃圾，因此名称）。

G1主要通过使用疏散来回收空间：在选定的存储区域中找到的活动对象被复制到新的存储区域中，在此过程中压缩它们。撤离完成后，活动对象先前占用的空间将被重新用于应用程序的分配。

Garbage-First收集器不是实时收集器。它试图在较长时间内以高概率满足设定的暂停时间目标，但对于给定的暂停并不总是绝对确定。

##### 2.2.4 堆布局

G1将堆分区为一组大小相等的堆区域，每个堆区域都是一个连续的虚拟内存区域，如图9-1所示。区域是内存分配和内存回收的单位。在任何给定时间，这些区域中的每一个都可以是空的（浅灰色），或者分配给特定的一代，无论年轻还是年老。随着内存请求的进入，内存管理器会分发免费区域。内存管理器将它们分配给一代，然后将它们作为可以自行分配的可用空间返回给应用程序。

图9-1 G1垃圾收集器堆布局

![下面是图9-1的描述](https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/jsgct_dt_004_grbg_frst_hp.png)

[“图9-1 G1垃圾收集器堆布局”的描述](https://docs.oracle.com/javase/9/gctuning/img_text/jsgct_dt_004_grbg_frst_hp.htm)

> 该图由10×10网格组成。大多数网格的单元格都是灰色的。19个细胞呈深蓝色。这些深蓝色单元随机分布在网格的上六行中。其中两个深蓝色单元格包含一个红色框。细胞两个细胞宽，一个细胞高（出现在第一行），细胞三个细胞宽，一个细胞高（出现在第六行），颜色为深蓝色，标记为“H”。八个单元格为浅蓝色，包含一个红色框。其中两个细胞标记为“S”。这些带有红色框的浅蓝色单元是随机分布的，大多数位于网格的上半部分。

年轻一代包含伊甸园区域（红色）和幸存区域（红色与“S”）。这些区域提供与其他收集器中的相应连续空间相同的功能，不同之处在于G1中这些区域通常以不连续的模式布置在存储器中。旧区（淡蓝色）构成了老一代。对于跨越多个区域的物体，老一代区域可能是巨大的（浅蓝色和“H”）。

应用程序总是分配给年轻一代，即伊甸园区域，除了直接分配为属于旧一代的大量对象。

G1垃圾收集暂停可以回收整个年轻一代的空间，任何收集的任何其他一组老一代区域都会暂停。在暂停期间，G1会将此*集合中的*对象复制到堆中的一个或多个不同区域。对象的目标区域取决于该对象的源区域：整个年轻代被复制到幸存者或旧区域，以及从旧区域到使用老化的其他不同旧区域的对象。



##### 2.2.5 垃圾收集周期

在高水平上，G1收集器在两个阶段之间交替。仅年轻阶段包含垃圾收集，逐渐填充当前可用内存和旧代中的对象。空间回收阶段是除了处理年轻一代之外，G1逐步回收老一代的空间。然后循环重新开始，只有一个年轻阶段。

图9-2给出了有关此循环的概述，并提供了可能发生的垃圾收集暂停序列的示例：

图9-2垃圾收集周期概述

![下面是图9-2的描述](https://raw.githubusercontent.com/451846939/Jdk-new-features/master/imges/jsgct_dt_001_grbgcltncyl.png)

[“图9-2垃圾收集周期概述”的说明](https://docs.oracle.com/javase/9/gctuning/img_text/jsgct_dt_001_grbgcltncyl.htm)

> 该图显示了G1阶段的顺序以及在这些阶段期间可能发生的暂停。有圆圈，每个圆圈代表一个垃圾收集暂停：蓝色圆圈表示仅限年轻人的收集暂停，橙色圆圈表示由标记引起的暂停，红色圆圈表示混合收集暂停。暂停在两个箭头上形成一个圆圈：一个用于在仅年轻阶段期间发生的暂停，另一个用于表示混合收集阶段。这个年轻人阶段的开始是一些由小蓝圈代表的年轻垃圾收集。在旧一代中的对象占用达到由InitiatingHeapOccupancyPercent定义的阈值之后，下一个垃圾收集暂停将是一个初始标记垃圾收集暂停，显示为较大的蓝色圆圈。除了与其他仅限年轻人的停顿相同的工作外，它还准备并行标记。
>
> 当并发标记正在运行时，可能会出现其他仅限年轻的暂停，直到备注暂停（第一个大橙色圆圈），其中G1完成标记。在清理暂停之前，可能会发生其他仅限年轻的垃圾收集。在清理暂停之后，将有一个最终的年轻垃圾收集完成仅限年轻的阶段。在空间回收阶段，将发生一系列混合收集，表示为红色圆圈。通常，在年轻阶段，混合垃圾收集暂停的次数少于仅限年轻人的暂停，因为G1努力使空间填海尽可能高效。

以下列表详细描述了阶段，它们的暂停以及G1垃圾收集周期阶段之间的转换：

1. 仅限年轻阶段：此阶段从一些仅限年轻人的集合开始，这些集合将对象推广到旧一代。只有年轻阶段和空间回收阶段之间的过渡开始于旧一代占用率达到一定阈值，即启动堆占用阈值。此时，G1计划初始标记仅限年轻人的集合，而不是常规的仅限年轻人的集合。
   - 初始标记：除了执行常规的仅限年轻的集合之外，此类集合还会启动标记过程。并发标记确定旧一代区域中当前可到达（实时）的所有对象，以便在下一个空间回收阶段保留。虽然标记尚未完全完成，但可能会出现常规的年轻收藏品。标记完成时有两个特殊的世界停顿：备注和清理。
   - 备注：此暂停最终确定标记本身，并执行全局引用处理和类卸载。在备注和清理之间G1同时计算活跃度信息的摘要，这些摘要将在清理暂停中最终确定并用于更新内部数据结构。
   - 清理：此暂停还会回收完全空白的区域，并确定是否实际遵循空间回收阶段。如果接下来是一个空间回收阶段，那么仅限年轻的阶段将完成一个仅限年轻人的收藏。
2. 空间回收阶段：该阶段由多个混合集合组成，除了年轻代区域外，还可以撤离旧一代区域的活动对象。当G1确定撤离更多的旧一代区域不会产生足够的自由空间值得努力时，空间回收阶段结束。

在空间回收之后，收集周期将以另一个仅限年轻的阶段重新开始。作为备份，如果应用程序在收集活动信息时内存不足，G1会像其他收集器一样执行就地停止全堆压缩（Full GC）。

#### 2.4 增强了Deprecated

> https://openjdk.java.net/jeps/277

`@Deprecated`

- 一个`forRemoval()`返回的方法`boolean`。如果`true`，则表示此API元素已指定在将来的版本中删除。如果`false`，API元素已弃用，但目前无意在将来的版本中删除它。该元素的默认值为`false`。

- 一个名为`since()`return 的方法`String`。此字符串应包含此API已弃用的版本号或版本号。它具有自由格式语法，但版本编号应遵循与`@since`包含已弃用API的项目的Javadoc标记相同的方案。请注意，此值对于Javadoc 标记*不是*多余的`@since`，因为它记录了引入API的版本，而注释中的`since()`方法 `@Deprecated`记录了不推荐使用API的版本。此元素的默认值为空字符串。

  增强`@Deprecated`注释的主要目的是为有关API弃用状态的工具提供更细粒度的信息。这些工具反过来使用注释向API用户报告信息。该`@Deprecated`注释具有运行时保留，并且因此消耗堆内存。因此，这里的信息应该是最小的和明确的。

增强@Deprecated注释的主要目的是为有关API弃用状态的工具提供更细粒度的信息。这些工具反过来使用注释向API用户报告信息。该@Deprecated注释具有运行时保留，并且因此消耗堆内存。因此，这里的信息应该是最小的和明确的。

以下元素将添加到java.lang.Deprecated 注释类型：

一个forRemoval()返回的方法boolean。如果true，则表示此API元素已指定在将来的版本中删除。如果false，API元素已弃用，但目前无意在将来的版本中删除它。该元素的默认值为false。

一个名为since()return 的方法String。此字符串应包含此API已弃用的版本号或版本号。它具有自由格式语法，但版本编号应遵循与@since包含已弃用API的项目的Javadoc标记相同的方案。请注意，此值对于Javadoc 标记不是多余的@since，因为它记录了引入API的版本，而注释中的since()方法 @Deprecated记录了不推荐使用API​​的版本。此元素的默认值为空字符串。

由于这些元素被添加到现有@Deprecated 注释中，因此注释处理程序将看到默认值forRemoval()以及since()它们是否正在处理使用@Deprecated早于JDK 9 的版本编译的类文件。

@DeprecatedAPI 上的注释的存在是从API的作者或维护者到API的用户的通信。最常见的是，弃用是建议用户从不推荐使用的API迁移其使用，避免从新代码或维护旧代码添加此API的依赖关系，或者维护依赖于此的代码存在一定的风险API。推荐此类迁移的原因有很多。原因可能包括以下内容：

API存在缺陷，修复起来不切实际，

使用API​​可能会导致错误，

API已被另一个API取代，

API已过时，

API是实验性的，并且会受到不兼容的更改，

或以上的任何组合。

弃用API的确切原因通常过于微妙，无法在注释中表示为标志或元素值。强烈建议在API的文档注释中描述弃用API的原因。此外，还建议从文档中讨论和链接潜在的替换API。

但是，提供了一个特定的标志值。该forRemoval()布尔元素，如果true，表明意图，该API元素是一些未来项目的版本中删除。因此，API的用户会收到预先警告，如果他们不从API迁移，则在升级到新版本时，他们的代码可能会中断。如果 forRemoval()是false，则表示建议从已弃用的API迁移，但没有任何特定意图删除该API。

的@Deprecated注释和@deprecatedJavadoc标记都应该是本或两者是API元件上不存在。一个没有另一个的存在被认为是一个错误。javac -Xlint:dep-ann，如果将发出警告@deprecated标签存在对缺少的API @Deprecated注释。如果相反，则目前没有警告; 见 JDK-8141234。

该@Deprecated注解应该有淘汰的API的行为没有直接影响，应该忽略的性能影响。

## JDK10

> https://openjdk.java.net/projects/jdk/
>
> https://openjdk.java.net/projects/jdk/10/

### 1.实现

jdk10实现规范`JSR 383`

> The official Reference Implementation for Java SE 10 ([JSR 383](https://www.jcp.org/en/jsr/detail?id=383)) is based solely upon open-source code available from the [JDK 10 Project](https://openjdk.java.net/projects/jdk/10/) in the [OpenJDK Community](https://openjdk.java.net/).
>
> https://www.jcp.org/en/jsr/detail?id=383

### 2.特征（Features）

> 286: [Local-Variable Type Inference](https://openjdk.java.net/jeps/286)
> 296: [Consolidate the JDK Forest into a Single Repository](https://openjdk.java.net/jeps/296)
> 304: [Garbage-Collector Interface](https://openjdk.java.net/jeps/304)
> 307: [Parallel Full GC for G1](https://openjdk.java.net/jeps/307)
> 310: [Application Class-Data Sharing](https://openjdk.java.net/jeps/310)
> 312: [Thread-Local Handshakes](https://openjdk.java.net/jeps/312)
> 313: [Remove the Native-Header Generation Tool (javah)](https://openjdk.java.net/jeps/313)
> 314: [Additional Unicode Language-Tag Extensions](https://openjdk.java.net/jeps/314)
> 316: [Heap Allocation on Alternative Memory Devices](https://openjdk.java.net/jeps/316)
> 317: [Experimental Java-Based JIT Compiler](https://openjdk.java.net/jeps/317)
> 319: [Root Certificates](https://openjdk.java.net/jeps/319)
> 322: [Time-Based Release Versioning](https://openjdk.java.net/jeps/322)

286：[局部变量类型推断](https://openjdk.java.net/jeps/286)
296：[将JDK林合并到单个存储库](https://openjdk.java.net/jeps/296)
304：[垃圾收集器接口](https://openjdk.java.net/jeps/304)
307：[用于G1](https://openjdk.java.net/jeps/307)的[并行完整GC](https://openjdk.java.net/jeps/307)
310：[应用程序类 - 数据共享](https://openjdk.java.net/jeps/310)
312：[线程局部握手](https://openjdk.java.net/jeps/312)
313：[移除本机头生成工具（javah）](https://openjdk.java.net/jeps/313)
314：[附加的Unicode语言 - 标记扩展](https://openjdk.java.net/jeps/314)
316：[替代存储器设备上的堆分配](https://openjdk.java.net/jeps/316)
317：[基于Java的实验JIT编译器](https://openjdk.java.net/jeps/317)
319：[根证书](https://openjdk.java.net/jeps/319)
322：[基于时间的发布版本控制](https://openjdk.java.net/jeps/322)

####  2.1 局部变量类型推断

> https://openjdk.java.net/jeps/286

我们通过减少与编写Java代码相关的仪式，同时保持Java对静态类型安全的承诺，通过允许开发人员忽略局部变量类型的经常不必要的清单声明来寻求改善开发人员体验。例如，此功能将允许声明，例如：

```
var list = new ArrayList<String>();  // infers ArrayList<String>
var stream = list.stream();          // infers Stream<String>
```

这种处理将局限于具有初始化器的局部变量，增强型`for`-loop中的索引以及传统`for`循环中声明的本地变量; 它不适用于方法形式，构造函数形式，方法返回类型，字段，捕获形式或任何其他类型的变量声明。

## JDK11

> https://openjdk.java.net/projects/jdk/11/
>
> https://cr.openjdk.java.net/~iris/se/11/spec/draft/latest/

### 1.实现

jdk11实现规范`JSR 384`

> JDK 11 is the open-source reference implementation of version 11 of the Java SE Platform as specified by by [JSR 384](https://openjdk.java.net/projects/jdk/11/spec) in the Java Community Process.
>
> https://www.jcp.org/en/jsr/detail?id=384

### 2.特征（Features）

> 181: [Nest-Based Access Control](https://openjdk.java.net/jeps/181)
> 309: [Dynamic Class-File Constants](https://openjdk.java.net/jeps/309)
> 315: [Improve Aarch64 Intrinsics](https://openjdk.java.net/jeps/315)
> 318: [Epsilon: A No-Op Garbage Collector](https://openjdk.java.net/jeps/318)
> 320: [Remove the Java EE and CORBA Modules](https://openjdk.java.net/jeps/320)
> 321: [HTTP Client (Standard)](https://openjdk.java.net/jeps/321)
> 323: [Local-Variable Syntax for Lambda Parameters](https://openjdk.java.net/jeps/323)
> 324: [Key Agreement with Curve25519 and Curve448](https://openjdk.java.net/jeps/324)
> 327: [Unicode 10](https://openjdk.java.net/jeps/327)
> 328: [Flight Recorder](https://openjdk.java.net/jeps/328)
> 329: [ChaCha20 and Poly1305 Cryptographic Algorithms](https://openjdk.java.net/jeps/329)
> 330: [Launch Single-File Source-Code Programs](https://openjdk.java.net/jeps/330)
> 331: [Low-Overhead Heap Profiling](https://openjdk.java.net/jeps/331)
> 332: [Transport Layer Security (TLS) 1.3](https://openjdk.java.net/jeps/332)
> 333: [ZGC: A Scalable Low-Latency Garbage Collector(Experimental)](https://openjdk.java.net/jeps/333)
> 335: [Deprecate the Nashorn JavaScript Engine](https://openjdk.java.net/jeps/335)
> 336: [Deprecate the Pack200 Tools and API](https://openjdk.java.net/jeps/336)

181：[基于嵌套的访问控制](https://openjdk.java.net/jeps/181)
309：[动态类 - 文件常量](https://openjdk.java.net/jeps/309)
315：[改进Aarch64内在函数](https://openjdk.java.net/jeps/315)
318：[Epsilon：无操作垃圾收集器](https://openjdk.java.net/jeps/318)
320：[移除Java EE和CORBA模块](https://openjdk.java.net/jeps/320)
321：[HTTP客户端（标准）](https://openjdk.java.net/jeps/321)
323：[本地变量Lambda参数](https://openjdk.java.net/jeps/323)的[语法](https://openjdk.java.net/jeps/323)
324：[与Curve25519和Curve448的密钥协议](https://openjdk.java.net/jeps/324)
327：[Unicode 10](https://openjdk.java.net/jeps/327)
328：[飞行记录器](https://openjdk.java.net/jeps/328)
329：[ChaCha20和Poly1305加密算法](https://openjdk.java.net/jeps/329)
330：[启动单文件源代码程序](https://openjdk.java.net/jeps/330)
331：[低开销堆分析](https://openjdk.java.net/jeps/331)
332：[传输层安全性（TLS）1.3](https://openjdk.java.net/jeps/332)
333：[ZGC：可扩展的低延迟垃圾收集器(实验性)](https://openjdk.java.net/jeps/333)
335：[弃用Nashorn JavaScript引擎](https://openjdk.java.net/jeps/335)
336：[弃用Pack200工具和API](https://openjdk.java.net/jeps/336)

#### 2.1 Lambda参数的本地变量语法

> https://openjdk.java.net/jeps/323

允许`var`在声明隐式类型的lambda表达式的形式参数时使用。

对于隐式类型的lambda表达式的形式参数，允许使用保留的类型名称`var`，以便：

```java
(var x, var y) -> x.process(y)
```

相当于：

```java
(x, y) -> x.process(y)
```

隐式类型的lambda表达式必须`var`用于其所有形式参数，或者不能用于任何形式参数。此外，`var`仅允许隐式类型化lambda表达式的形式参数---显式类型化的lambda表达式继续为其*所有*形式参数指定清单类型，因此某些形式参数不允许其他人使用清单类型`var`。以下示例是非法的：

```java
(var x, y) -> x.process(y)         // Cannot mix 'var' and 'no var' in implicitly typed lambda expression
(var x, int y) -> x.process(y)     // Cannot mix 'var' and manifest types in explicitly typed lambda expression
```

从理论上讲，可能有一个像上面最后一行一样的lambda表达式，它是半显式类型（或半隐式类型，取决于你的观点）。但是，它超出了此JEP的范围，因为它会深刻影响类型推断和重载决策。这是保持lambda表达式必须指定所有清单参数类型或不指定的限制的主要原因。我们还希望强制推断隐式类型化lambda表达式的参数的类型是否相同无论是否`var`使用。我们可能会在未来的JEP中回到局部推断的问题。此外，我们不希望损害简写语法的简洁性，因此我们不允许使用以下表达式：

```java
var x -> x.foo()
```

#### 2.2 ZGC

> https://openjdk.java.net/jeps/333
>
> https://docs.oracle.com/en/java/javase/11/gctuning/index.html
>
> https://wiki.openjdk.java.net/display/zgc/Main

> At a glance, ZGC is a concurrent, single-generation, region-based, NUMA-aware, compacting collector. Stop-the-world phases are limited to root scanning, so GC pause times do not increase with the size of the heap or the live set.
>
> A core design principle/choice in ZGC is the use of load barriers in combination with colored object pointers (i.e., colored oops). This is what enables ZGC to do concurrent operations, such as object relocation, while Java application threads are running. From a Java thread's perspective, the act of loading a reference field in a Java object is subject to a load barrier. In addition to an object address, a colored object pointer contains information used by the load barrier to determine if some action needs to be taken before allowing a Java thread to use the pointer. For example, the object might have been relocated, in which case the load barrier will detect the situation and take appropriate action.
>
> Compared to alternative techniques, we believe the colored-pointers scheme offers some very attractive properties. In particular:
>
> - It allows us to reclaim and reuse memory during the relocation/compaction phase, before pointers pointing into the reclaimed/reused regions have been fixed. This helps keep the general heap overhead down. It also means that there is no need to implement a separate mark-compact algorithm to handle a full GC.
> - It allows us to have relatively few and simple GC barriers. This helps keep the runtime overhead down. It also means that it's easier to implement, optimize and maintain the GC barrier code in our interpreter and JIT compilers.
> - We currently store marking and relocation related information in the colored pointers. However, the versatile nature of this scheme allows us to store any type of information (as long as we can fit it into the pointer) and let the load barrier take any action it wants to based on that information. We believe this will lay the foundation for many future features. To pick one example, in a heterogeneous memory environment, this could be used to track heap access patterns to guide GC relocation decisions to move rarely used objects to cold storage.

> 一目了然，ZGC是一个并发的，单一代的，基于区域的，NUMA感知的压缩收集器。世界各地的阶段仅限于根扫描，因此GC暂停时间不会随着堆的大小或实时集的增加而增加。
>
> ZGC的核心设计原则/选择是将负载障碍与彩色对象指针（即彩色哎呀）结合使用。这使得ZGC能够在Java应用程序线程运行时执行并发操作，例如对象重定位。从Java线程的角度来看，在Java对象中加载引用字段的行为受到加载障碍的影响。除了对象地址之外，有色对象指针还包含加载屏障使用的信息，以确定在允许Java线程使用指针之前是否需要采取某些操作。例如，对象可能已被重新定位，在这种情况下，加载屏障将检测情况并采取适当的操作。
>
> 与替代技术相比，我们认为彩色指针方案提供了一些非常有吸引力的特性。尤其是：
>
> - 它允许我们在重定位/压缩阶段回收和重用内存，然后修复指向回收/重用区域的指针。这有助于降低一般堆开销。这也意味着不需要实现单独的mark-compact算法来处理完整的GC。
> - 它允许我们拥有相对较少且简单的GC障碍。这有助于降低运行时开销。这也意味着在我们的解释器和JIT编译器中实现，优化和维护GC屏障代码更容易。
> - 我们目前在彩色指针中存储标记和重定位相关信息。但是，这种方案的通用性使我们能够存储任何类型的信息（只要我们可以将它放入指针中），并让负载屏障根据该信息采取它想要的任何动作。我们相信这将为未来的许多功能奠定基础。举一个例子，在异构内存环境中，这可以用于跟踪堆访问模式，以指导GC重定位决策，以便将很少使用的对象移动到冷存储。

Z垃圾收集器（ZGC）是一个可扩展的低延迟垃圾收集器。ZGC同时执行所有昂贵的工作，而不会停止执行应用程序线程超过10毫秒，这使得它适用于需要低延迟和/或使用非常大的堆（多兆兆字节）的应用程序。

Z垃圾收集器可用作实验性功能，并使用命令行选项启用` -XX:+UnlockExperimentalVMOptions -XX:+UseZGC`。

**Z垃圾收集器**，也称为**ZGC**，是一种可扩展的低延迟垃圾收集器，旨在实现以下目标：

- 暂停时间**不**超过**10毫秒**
- 暂停时间**不会**随堆或实时设置大小**而**增加
- 处理堆范围从**几百兆**到**多兆兆字节**大小

一目了然，ZGC是：

- 同时
- 基于区域的
- 压实
- NUMA感知
- 使用彩色指针
- 使用负载障碍

ZGC的核心是**并发**垃圾收集器，这意味着所有繁重的工作都在**Java线程继续执行时完成**。这极大地限制了垃圾收集对应用程序响应时间的影响。

 **支持的平台**

ZGC目前可在**Linux / x64**和**Linux / AArch64上使用**（从JDK 13开始）。将来会增加对其他平台的支持。

## JDK12

> https://openjdk.java.net/projects/jdk/12/

### 1.实现

jdk12实现规范`JSR 386`

> https://openjdk.java.net/projects/jdk/12/spec/
>
> https://www.jcp.org/en/jsr/detail?id=386

### 2.特征（Features）

> | 189: | [Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)](https://openjdk.java.net/jeps/189) |
> | ---- | ------------------------------------------------------------ |
> | 230: | [Microbenchmark Suite](https://openjdk.java.net/jeps/230)    |
> | 325: | [Switch Expressions (Preview)](https://openjdk.java.net/jeps/325) |
> | 334: | [JVM Constants API](https://openjdk.java.net/jeps/334)       |
> | 340: | [One AArch64 Port, Not Two](https://openjdk.java.net/jeps/340) |
> | 341: | [Default CDS Archives](https://openjdk.java.net/jeps/341)    |
> | 344: | [Abortable Mixed Collections for G1](https://openjdk.java.net/jeps/344) |
> | 346: | [Promptly Return Unused Committed Memory from G1](https://openjdk.java.net/jeps/346) |

| 189： | [Shenandoah：低暂停时间垃圾收集器（实验性）](https://openjdk.java.net/jeps/189) |
| ----- | ------------------------------------------------------------ |
| 230： | [Microbenchmark套房](https://openjdk.java.net/jeps/230)      |
| 325： | [切换表达式（预览）](https://openjdk.java.net/jeps/325)      |
| 334： | [JVM常量API](https://openjdk.java.net/jeps/334)              |
| 340： | [一个AArch64端口，而不是两个](https://openjdk.java.net/jeps/340) |
| 341： | [默认CDS档案](https://openjdk.java.net/jeps/341)             |
| 344： | [G1的可流动混合收集](https://openjdk.java.net/jeps/344)      |
| 346： | [从G1中立即返回未使用的已提交内存](https://openjdk.java.net/jeps/346) |

#### 2.1 [Switch Expressions (Preview)](https://openjdk.java.net/jeps/325)

> https://openjdk.java.net/jeps/325

> In additional to "traditional" switch blocks, we propose to add a new "simplified" form, with new "`case L ->`" switch labels. If a label is matched, then only the expression or statement to the right of an arrow label is executed; there is no fall through. For example, given the method:
>
> ```
> static void howMany(int k) {
>     switch (k) {
>         case 1 -> System.out.println("one");
>         case 2 -> System.out.println("two");
>         case 3 -> System.out.println("many");
>     }
> }
> ```
>
> The following code:
>
> ```
> howMany(1);
> howMany(2);
> howMany(3);
> ```
>
> results in the following output:
>
> ```
> one
> two
> many
> ```
>
> We will extend the `switch` statement so that it can additionally be used as an expression. In the common case, a `switch` expression will look like:
>
> ```
> T result = switch (arg) {
>     case L1 -> e1;
>     case L2 -> e2;
>     default -> e3;
> };
> ```
>
> A `switch` expression is a poly expression; if the target type is known, this type is pushed down into each arm. The type of a `switch` expression is its target type, if known; if not, a standalone type is computed by combining the types of each case arm.
>
> Most `switch` expressions will have a single expression to the right of the "`case L ->`" switch label. In the event that a full block is needed, we have extended the `break` statement to take an argument, which becomes the value of the enclosing `switch` expression.
>
> ```
> int j = switch (day) {
>     case MONDAY  -> 0;
>     case TUESDAY -> 1;
>     default      -> {
>         int k = day.toString().length();
>         int result = f(k);
>         break result;
>     }
> };
> ```
>
> A `switch` expression can, like a `switch` statement, also use a "traditional" switch block with "`case L:`" switch labels (implying fall-through semantics). In this case values would be yielded using the `break` with value statement:
>
> ```
> int result = switch (s) {
>     case "Foo": 
>         break 1;
>     case "Bar":
>         break 2;
>     default:
>         System.out.println("Neither Foo nor Bar, hmmm...");
>         break 0;
> };
> ```
>
> The two forms of `break` (with and without value) are analogous to the two forms of `return` in methods. Both forms of `return` terminate the execution of the method immediately; in a non-void method, additionally a value must be provided which is yielded to the invoker of the method. (Ambiguities between the `break` expression-value and `break` label forms can be handled relatively easily.)
>
> The cases of a `switch` expression must be exhaustive; for any possible value there must be a matching switch label. In practice this normally means simply that a `default` clause is required; however, in the case of an `enum` `switch` expression that covers all known cases (and eventually, `switch` expressions over sealed types), a `default` clause can be inserted by the compiler that indicates that the `enum` definition has changed between compile-time and runtime. (This is what developers do by hand today, but having the compiler insert it is both less intrusive and likely to have a more descriptive error message than the ones written by hand.)
>
> Furthermore, a `switch` expression must complete normally with a value, or `throw` an exception. This has a number of consequences. First, the compiler checks that for every switch label, if it is matched then a value can be yielded.
>
> ```
> int i = switch (day) {
>     case MONDAY -> {
>         System.out.println("Monday"); 
>         // ERROR! Block doesn't contain a break with value
>     }
>     default -> 1;
> };
> i = switch (day) {
>     case MONDAY, TUESDAY, WEDNESDAY: 
>         break 0;
>     default: 
>         System.out.println("Second half of the week");
>         // ERROR! Group doesn't contain a break with value
> };
> ```
>
> A further consequence is that the control statements, `break`, `return` and `continue`, cannot jump through a `switch` expression, such as in the following:
>
> ```
> z: 
>     for (int i = 0; i < MAX_VALUE; ++i) {
>         int k = switch (e) { 
>             case 0:  
>                 break 1;
>             case 1:
>                 break 2;
>             default: 
>                 continue z; 
>                 // ERROR! Illegal jump through a switch expression 
>         };
>     ...
>     }
> ```
>
> As a target of opportunity, we may expand switch to support switching on primitive types (and their box types) that have previously been disallowed, such as float, double, and long.

#### 2.2 从G1返回未使用的提交内存

> https://openjdk.java.net/jeps/346

为了实现向操作系统返回最大内存量的目标，G1将在应用程序不活动期间定期尝试继续或触发并发周期以确定整体Java堆使用情况。这将导致它自动将Java堆的未使用部分返回给操作系统。（可选）在用户控制下，可以执行完整的GC以最大化返回的内存量。

该应用程序被视为非活动状态，如果两者都发生，G1会触发定期垃圾收集

- `G1PeriodicGCInterval`自任何先前的垃圾收集暂停以来已经过了超过毫秒，并且此时没有正在进行的并发周期。值为零表示禁用快速回收内存的定期垃圾收集。
- 由`getloadavg()`JVM主机系统（例如容器）上的调用返回的平均一分钟系统负载值如下`G1PeriodicGCSystemLoadThreshold`。如果`G1PeriodicGCSystemLoadThreshold`为零，则忽略该条件。

如果不满足这些条件中的任何一个，则取消当前的预期定期垃圾收集。下次时间过后，将重新考虑定期垃圾收集`G1PeriodicGCInterval`。

定期垃圾收集的类型由`G1PeriodicGCInvokesConcurrent`选项的值确定：如果设置，G1继续或启动并发周期，否则G1执行完整的GC。在任一集合的末尾，G1调整当前的Java堆大小，可能会将内存返回给操作系统。新的Java堆大小由现有配置用于调整所述Java堆大小，包括确定，但不限于`MinHeapFreeRatio`，在`MaxHeapFreeRatio`，以及最小和最大堆大小配置。

默认情况下，G1在此定期垃圾回收期间启动或继续并发循环。这最大限度地减少了应用程序的中断，但与完整集合相比，最终可能无法返回尽可能多的内存。

由此机制触发的任何垃圾收集都会被标记为`G1 Periodic Collection`原因。此类日志的外观示例如下：

```
(1) [6.084s][debug][gc,periodic ] Checking for periodic GC.
    [6.086s][info ][gc          ] GC(13) Pause Young (Concurrent Start) (G1 Periodic Collection) 37M->36M(78M) 1.786ms
(2) [9.087s][debug][gc,periodic ] Checking for periodic GC.
    [9.088s][info ][gc          ] GC(15) Pause Young (Prepare Mixed) (G1 Periodic Collection) 9M->9M(32M) 0.722ms
(3) [12.089s][debug][gc,periodic ] Checking for periodic GC.
    [12.091s][info ][gc          ] GC(16) Pause Young (Mixed) (G1 Periodic Collection) 9M->5M(32M) 1.776ms
(4) [15.092s][debug][gc,periodic ] Checking for periodic GC.
    [15.097s][info ][gc          ] GC(17) Pause Young (Mixed) (G1 Periodic Collection) 5M->1M(32M) 4.142ms
(5) [18.098s][debug][gc,periodic ] Checking for periodic GC.
    [18.100s][info ][gc          ] GC(18) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M->1M(32M) 1.685ms
(6) [21.101s][debug][gc,periodic ] Checking for periodic GC.
    [21.102s][info ][gc          ] GC(20) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M->1M(32M) 0.868ms
(7) [24.104s][debug][gc,periodic ] Checking for periodic GC.
    [24.104s][info ][gc          ] GC(22) Pause Young (Concurrent Start) (G1 Periodic Collection) 1M->1M(32M) 0.778ms
```

在上面的例子中，具有运行`G1PeriodicGCInterval`3000ms的，在步骤（1）G1发起并发周期，由所指示的`(Concurrent Start)`和`(G1 Periodic Collection)`，本申请的一些不活动之后。这个并发周期最初返回一些内存，由容量数量的减少`(78M)`和`(32M)`（1）到（2）表示。在（2）到（4）之间的间隔中，触发更多的周期性集合，这次触发混合集合以压缩堆。以下定期垃圾收集（5）到（7）启动并发周期，因为G1策略确定当时在旧一代中没有足够的垃圾来启动混合GC阶段。在这种情况下，定期垃圾收集（5）到（7）不会进一步缩小堆，因为已经达到最小堆大小。

在应用程序不活动期间对对象活跃性的更改（例如，由于软引用到期）可能会在该空闲时间内触发进一步减少已提交的Java堆。

## JDK13

> https://openjdk.java.net/projects/jdk/13/
>
> https://cr.openjdk.java.net/~iris/se/13/spec/pr/java-se-13-pr-spec/java-se-13-pr-spec.html

### 1.实现

jdk13实现规范`jsr388`

> JDK 13 is the open-source reference implementation of version 13 of the Java SE Platform as specified by by [JSR 388](https://openjdk.java.net/projects/jdk/13/spec) in the Java Community Process.

> https://www.jcp.org/en/jsr/detail?id=388
>
> https://openjdk.java.net/projects/jdk/13/spec/

### 2.特征

> | 350: | [Dynamic CDS Archives](https://openjdk.java.net/jeps/350)    |
> | ---- | ------------------------------------------------------------ |
> | 351: | [ZGC: Uncommit Unused Memory](https://openjdk.java.net/jeps/351) |
> | 353: | [Reimplement the Legacy Socket API](https://openjdk.java.net/jeps/353) |
> | 354: | [Switch Expressions (Preview)](https://openjdk.java.net/jeps/354) |
> | 355: | [Text Blocks (Preview)](https://openjdk.java.net/jeps/355)   |

| 350： | [动态CDS档案](https://openjdk.java.net/jeps/350)             |
| ----- | ------------------------------------------------------------ |
| 351： | [ZGC：返回申请使用后空闲的内存](https://openjdk.java.net/jeps/351) |
| 353： | [重新实现旧版套接字API](https://openjdk.java.net/jeps/353)   |
| 354： | [切换表达式（预览）](https://openjdk.java.net/jeps/354)      |
| 355： | [文字块（预览）](https://openjdk.java.net/jeps/355)          |

#### 2.1 ZGC返回申请内存后空闲的内存

> The ZGC heap consists of a set of heap regions called *ZPages*. Each ZPage is associated with a variable amount of committed heap memory. When ZGC compacts the heap, ZPages are freed up and inserted into a page cache, the *ZPageCache*. ZPages in the page cache are ready to be reused to satisfy new heap allocations, in which case they are removed from the cache. The page cache is critical for performance, as committing and uncommitting memory are expensive operations.
>
> The set of ZPages in the page cache represent the unused parts of the heap that *could* be uncommitted and returned to the operating system. Uncommitting memory can be therefore done by simply evicting a well chosen set of ZPages from the page cache, and uncommitting the memory associated with these pages. The page cache already keeps ZPages in least-recently-used (LRU) order and segregated by size (small, medium, and large), so the mechanics of evicting ZPages and uncommitting memory is relatively straightforward. The challenge lies in designing the policy that decides when it's time to evict a ZPage from the cache.
>
> A simple policy would be to have a timeout or delay value that specifies how long a ZPage can sit in the page cache before it's evicted. This timeout would have some reasonable default value, with a command line option to override it. The Shenandoah GC uses a policy like this, with a default value of 5 minutes and the command line option `-XX:ShenandoahUncommitDelay=<milliseconds>` to override the default.
>
> A policy like the one above might work reasonably well. However, one could also envision more sophisticated policies that don't involve adding new command line options. For example, heuristics that find a suitable timeout value based on GC frequency, or some other data. We will initially deliver a simple timeout policy, with a `-XX:ZUncommitDelay=<seconds>` option, and let a more sophisticated policy (if one is found) come later.
>
> The uncommit capability will be enabled by default. But whatever the policy decides, ZGC should never uncommit memory so that the heap goes below its minimum size (`-Xms`). This mean the uncommit capability is effectively disabled if the JVM is started with a minimum heap size (`-Xms`) that is equal to the maximum heap size (`-Xmx`). The option `-XX:-ZUncommit` will also be provided to explicitly disable this feature.
>
> Finally, ZGC on Linux/x64 uses a tmpfs or hugetlbfs file to back the heap. Uncommitting memory used by these files requires `fallocate(2)` with `FALLOC_FL_PUNCH_HOLE` support, which first appeared in Linux 3.5 (tmpfs) and 4.3 (hugetlbfs). ZGC should continue to work as before when running on older Linux kernels, with the exception that the uncommit capability is disabled.

ZGC堆由一组称为*ZPages*的堆区域*组成*。每个ZPage都与可变数量的已提交堆内存相关联。当ZGC压缩堆时，ZPages被释放并插入页面缓存*ZPageCache*。页面缓存中的ZPages已准备好重新使用以满足新的堆分配，在这种情况下，它们将从缓存中删除。页面缓存对性能至关重要，因为提交和取消提交内存是昂贵的操作。

该组在页面缓存ZPages的代表堆中的未使用的部分*可能*是未提交并返回到操作系统。因此，通过简单地从页面缓存中逐出一组精心选择的ZPages，并且取消提交与这些页面相关联的存储器，可以完成取消提交内存。页面缓存已经将ZPages保持在最近最少使用（LRU）顺序并按大小（小，中，大）隔离，因此驱逐ZPages和取消内存的机制相对简单。挑战在于设计决定何时从缓存中驱逐ZPage的策略。

一个简单的策略是具有超时或延迟值，该值指定ZPage在被逐出之前可以在页面缓存中停留多长时间。此超时将具有一些合理的默认值，使用命令行选项覆盖它。Shenandoah GC使用这样的策略，默认值为5分钟，命令行选项`-XX:ShenandoahUncommitDelay=<milliseconds>`覆盖默认值。

像上面这样的政策可能会运作得相当好。但是，人们还可以设想更复杂的策略，不涉及添加新的命令行选项。例如，基于GC频率或某些其他数据找到合适超时值的启发式算法。我们将首先提供一个简单的超时策略，带有一个`-XX:ZUncommitDelay=<seconds>`选项，让更复杂的策略（如果找到的话）稍后出现。

默认情况下将启用uncommit功能。但是无论策略决定什么，ZGC都不应该忘记内存，以便堆低于其最小大小（`-Xms`）。这意味着如果以最小堆大小（`-Xms`）等于最大堆大小（`-Xmx`）启动JVM，则有效禁用uncommit功能。`-XX:-ZUncommit`还将提供该选项以明确禁用此功能。

最后，Linux / x64上的ZGC使用tmpfs或hugetlbfs文件来备份堆。由这些文件中使用Uncommitting存储器需要`fallocate(2)`与`FALLOC_FL_PUNCH_HOLE`支持，其首先出现在Linux的3.5（TMPFS）和4.3（hugetlbfs的）。在旧的Linux内核上运行时，ZGC应该像以前一样继续工作，但禁用了uncommit功能。

#### 2.2 文本块（预览）

> https://openjdk.java.net/jeps/355

> In Java, embedding a snippet of HTML, XML, SQL, or JSON in a string literal `"..."` usually requires significant editing with escapes and concatenation before the code containing the snippet will compile. The snippet is often difficult to read and arduous to maintain.
>
> More generally, the need to denote short, medium, and long blocks of text in a Java program is near universal, whether the text is code from other programming languages, structured text representing golden files, or messages in natural languages. On the one hand, the Java language recognizes this need by allowing strings of unbounded size and content, but on the other hand, it embodies a design default that strings should be small enough to denote on a single line of a source file, and simple enough to escape easily. The Java language can be regularized by accepting that strings may be large enough to span multiple lines of a source file, and by envisaging that escapes in their content may represent formatting and layout operations as well as individual characters.
>
> Accordingly, it would improve both the readability and the writeability of a broad class of Java programs to have a linguistic mechanism for denoting strings more literally than a string literal -- across multiple lines and without the visual clutter of escapes. In essence, a two-dimensional block of text, rather than a one-dimensional sequence of characters.
>
> ### HTML example
>
> *Using "one-dimensional" string literals*
>
> ```
> String html = "<html>\n" +
>               "    <body>\n" +
>               "        <p>Hello, world</p>\n" +
>               "    </body>\n" +
>               "</html>\n";
> ```
>
> *Using a "two-dimensional" block of text*
>
> ```
> String html = """
>               <html>
>                   <body>
>                       <p>Hello, world</p>
>                   </body>
>               </html>
>               """;
> ```
>
> ### SQL example
>
> *Using "one-dimensional" string literals*
>
> ```
> String query = "SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n" +
>                "WHERE `CITY` = 'INDIANAPOLIS'\n" +
>                "ORDER BY `EMP_ID`, `LAST_NAME`;\n";
> ```
>
> *Using a "two-dimensional" block of text*
>
> ```
> String query = """
>                SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`
>                WHERE `CITY` = 'INDIANAPOLIS'
>                ORDER BY `EMP_ID`, `LAST_NAME`;
>                """;
> ```
>
> ### Polyglot language example
>
> *Using "one-dimensional" string literals*
>
> ```
> ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
> Object obj = engine.eval("function hello() {\n" +
>                          "    print('\"Hello, world\"');\n" +
>                          "}\n" +
>                          "\n" +
>                          "hello();\n");
> ```
>
> *Using a "two-dimensional" block of text*
>
> ```
> ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
> Object obj = engine.eval("""
>                          function hello() {
>                              print('"Hello, world"');
>                          }
>                          
>                          hello();
>                          """);
> ```
>
> ## Description
>
> A *text block* is a new kind of literal in the Java language. It may be used to denote a string anywhere that a *string literal* could appear, but offers greater expressiveness and less accidental complexity.
>
> A text block consists of zero or more content characters, enclosed by opening and closing delimiters.
>
> The *opening delimiter* is a sequence of three double quote characters (`"""`) followed by zero or more white spaces followed by a line terminator. The *content* begins at the first character after the line terminator of the opening delimiter.
>
> The *closing delimiter* is a sequence of three double quote characters. The content ends at the last character before the first double quote of the closing delimiter.
>
> The content may include double quote characters directly, unlike the characters in a string literal. The use of `\"` in a text block is permitted, but not necessary or recommended. Fat delimiters (`"""`) were chosen so that `"` characters could appear unescaped, and also to visually distinguish a text block from a string literal.
>
> The content may include line terminators directly, unlike the characters in a string literal. The use of `\n` in a text block is permitted, but not necessary or recommended. For example, the text block:
>
> ```
> """
> line 1
> line 2
> line 3
> """
> ```
>
> is equivalent to the string literal:
>
> ```
> "line 1\nline 2\nline 3\n"
> ```
>
> or a concatenation of string literals:
>
> ```
> "line 1\n" +
> "line 2\n" +
> "line 3\n"
> ```
>
> If a line terminator is not required at the end of the string, then the closing delimiter can be placed on the last line of content. For example, the text block:
>
> ```
> """
> line 1
> line 2
> line 3"""
> ```
>
> is equivalent to the string literal:
>
> ```
> "line 1\nline 2\nline 3"
> ```
>
> A text block can denote the empty string, although this is not recommended because it needs two lines of source code:
>
> ```
> String empty = """
> """;
> ```
>
> Here are some examples of ill-formed text blocks:
>
> ```
> String a = """""";   // no line terminator after opening delimiter
> String b = """ """;  // no line terminator after opening delimiter
> String c = """
>            ";        // no closing delimiter (text block continues to EOF)
> String d = """
>            abc \ def
>            """;      // unescaped backslash (see below for escape processing)
> ```
>
> ### Compile-time processing
>
> A text block is a [constant expression](https://docs.oracle.com/javase/specs/jls/se12/html/jls-15.html#jls-15.28) of type `String`, just like a string literal. However, unlike a string literal, the content of a text block is processed by the Java compiler in three distinct steps:
>
> 1. Line terminators in the content are translated to LF (`\u000A`). The purpose of this translation is to follow the principle of least surprise when moving Java source code across platforms.
> 2. Incidental white space surrounding the content, introduced to match the indentation of Java source code, is removed.
> 3. Escape sequences in the content are interpreted. Performing interpretation as the final step means developers can write escape sequences such as `\n` without them being modified or deleted by earlier steps.
>
> The processed content is recorded in the `class` file as a `CONSTANT_String_info` entry in the constant pool, just like the characters of a string literal. The `class` file does not record whether a `CONSTANT_String_info` entry was derived from a text block or a string literal.
>
> At run time, a text block is evaluated to an instance of `String`, just like a string literal. Instances of `String` that are derived from text blocks are indistinguishable from instances derived from string literals. Two text blocks with the same processed content will refer to the same instance of `String` due to [interning](https://docs.oracle.com/javase/specs/jvms/se12/html/jvms-5.html#jvms-5.1-300), just like for [string literals](https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-3.10.5-410).
>
> The following sections discuss the compile-time processing in more detail.
>
> #### 1. Line terminators
>
> Line terminators in the content are *normalized* from CR (`\u000D`) and CRLF (`\u000D\u000A`) to LF (`\u000A`) by the Java compiler. This ensures that the string derived from the content is equivalent across platforms, even if the source code has been translated to a platform encoding (see `javac -encoding`).
>
> For example, if Java source code that was created on a Unix platform (where the line terminator is LF) is edited on a Windows platform (where the line terminator is CRLF), then without normalization, the content would become one character longer for each line. Any algorithm that relied on LF being the line terminator might fail, and any test that needed to verify string equality with `String::equals` would fail.
>
> The escape sequences `\n` (LF), `\f` (FF), and `\r` (CR) are *not* interpreted during normalization; escape processing happens later.
>
> #### 2. Incidental white space
>
> The text blocks in the Motivation were easier to read than their concatenated string literal counterparts, but the obvious interpretation for the content of a text block would include the spaces added to indent the embedded string so that it lines up neatly with the opening delimiter. Here is the HTML example using dots to visualize the spaces that the developer added for indentation:
>
> ```
> String html = """
> ..............<html>
> ..............    <body>
> ..............        <p>Hello, world</p>
> ..............    </body>
> ..............</html>
> ..............""";
> ```
>
> Since the opening delimiter is generally positioned to appear on the same line as the statement or expression which consumes the text block, there is no real significance to the fact that 14 visualized spaces start each line. Including those spaces in the content would mean the text block denotes a string different from the one denoted by the concatenated string literals. This would hurt migration, and be a recurring source of surprise: it is overwhelmingly likely that the developer does *not* want those spaces in the string. Also, the closing delimiter is generally positioned to align with the content, which further suggests that the 14 visualized spaces are insignificant.
>
> Spaces may also appear at the end of each line, especially when a text block is populated by copy-pasting snippets from other files (which may themselves have been formed by copy-pasting from yet more files). Here is the HTML example reimagined with some trailing white space, again using dots to visualize spaces:
>
> ```
> String html = """
> ..............<html>...
> ..............    <body>
> ..............        <p>Hello, world</p>....
> ..............    </body>.
> ..............</html>...
> ..............""";
> ```
>
> Trailing white space is most often unintentional, idiosyncractic, and insignificant. It is overwhelmingly likely that the developer does not care about it. Trailing white space characters are similar to line terminators, in that both are invisible artifacts of the source code editing environment. With no visual guide to the presence of trailing white space characters, including them in the content would be a recurring source of surprise, as it would affect the length, hash code, etc, of the string.
>
> Accordingly, an appropriate interpretation for the content of a text block is to differentiate *incidental white space* at the start and end of each line, from *essential white space*. The Java compiler processes the content by removing incidental white space to yield what the developer intended. `String::indent` can then be used to manage indentation if desired. Using `|` to visualize margins:
>
> ```
> |<html>|
> |    <body>|
> |        <p>Hello, world</p>|
> |    </body>|
> |</html>|
> ```
>
> The *re-indentation algorithm* takes the content of a text block whose line terminators have been normalized to LF. It removes the same amount of white space from each line of content until at least one of the lines has a non-white space character in the leftmost position. The position of the opening `"""` characters has no effect on the algorithm, but the position of the closing `"""` characters does have an effect if placed on its own line. The algorithm is as follows:
>
> 1. Split the content of the text block at every LF, producing a list of *individual lines*. Note that any line in the content which was just an LF will become an empty line in the list of individual lines.
> 2. Add all *non-blank* lines from the list of individual lines into a set of *determining lines*. (Blank lines -- lines that are empty or are composed wholly of white space -- have no visible influence on the indentation. Excluding blank lines from the set of determining lines avoids throwing off step 4 of the algorithm.)
> 3. If the last line in the list of individual lines (i.e., the line with the closing delimiter) is *blank*, then add it to the set of determining lines. (The indentation of the closing delimiter should influence the indentation of the content as a whole -- a "significant trailing line" policy.)
> 4. Compute the *common white space prefix* of the set of determining lines, by counting the number of leading white space characters on each line and taking the minimum count.
> 5. Remove the common white space prefix from each *non-blank* line in the list of individual lines.
> 6. Remove all trailing white space from all lines in the modified list of individual lines from step 5. This step collapses wholly-whitespace lines in the modified list so that they are empty, but does not discard them.
> 7. Construct the result string by joining all the lines in the modified list of individual lines from step 6, using LF as the separator between lines. If the final line in the list from step 6 is empty, then the joining LF from the previous line will be the last character in the result string.
>
> The escape sequences `\b` (backspace) and `\t` (tab) are *not* interpreted by the algorithm; escape processing happens later.
>
> The re-indentation algorithm will be normative in *The Java Language Specification*. Developers will have access to it via `String::stripIndent`, a new instance method.
>
> #### Significant trailing line policy
>
> Normally, one would format a text block in two ways: first, position the left edge of the content to appear under the first `"` of the opening delimiter, and second, place the closing delimiter on its own line to appear exactly under the opening delimiter. The resulting string will have no white space at the start of any line, and will not include the trailing blank line of the closing delimiter.
>
> However, because the trailing blank line is considered a *determining line*, moving it to the left has the effect of reducing the common white space prefix, and therefore reducing the the amount of white space that is stripped from the start of every line. In the extreme case, where the closing delimiter is moved all the way to the left, that reduces the common white space prefix to zero, effectively opting out of white space stripping.
>
> For example, with the closing delimiter moved all the way to the left, there is no incidental white space to visualize with dots:
>
> ```
> String html = """
>               <html>
>                   <body>
>                       <p>Hello, world</p>
>                   </body>
>               </html>
> """;
> ```
>
> Including the trailing blank line with the closing delimiter, the common white space prefix is zero, so zero white space is removed from the start of each line. The algorithm thus produces: (using `|` to visualize the left margin)
>
> ```
> |              <html>
> |                  <body>
> |                      <p>Hello, world</p>
> |                  </body>
> |              </html>
> ```
>
> Alternatively, suppose the closing delimiter is not moved all the way to the left, but rather under the `t` of `html` so it is eight spaces deeper than the variable declaration:
>
> ```
> String html = """
>               <html>
>                   <body>
>                       <p>Hello, world</p>
>                   </body>
>               </html>
>         """;
> ```
>
> The spaces visualized with dots are considered to be incidental:
>
> ```
> String html = """
> ........      <html>
> ........          <body>
> ........              <p>Hello, world</p>
> ........          </body>
> ........      </html>
> ........""";
> ```
>
> Including the trailing blank line with the closing delimiter, the common white space prefix is eight, so eight white spaces are removed from the start of each line. The algorithm thus preserves the essential indentation of the content relative to the closing delimiter:
>
> ```
> |      <html>
> |          <body>
> |              <p>Hello, world</p>
> |          </body>
> |      </html>
> ```
>
> Finally, suppose the closing delimiter is moved slightly to the *right* of the content:
>
> ```
> String html = """
>               <html>
>                   <body>
>                       <p>Hello, world</p>
>                   </body>
>               </html>
>                   """;
> ```
>
> The spaces visualized with dots are considered to be incidental:
>
> ```
> String html = """
> ..............<html>
> ..............    <body>
> ..............        <p>Hello, world</p>
> ..............    </body>
> ..............</html>
> ..............    """;
> ```
>
> The common white space prefix is 14, so 14 white spaces are removed from the start of each line. The trailing blank line is stripped to leave an empty line, which being the last line is then discarded. In other words, moving the closing delimiter to the right of the content has no effect, and the algorithm again preserves the essential indentation of the content:
>
> ```
> |<html>
> |    <body>
> |        <p>Hello, world</p>
> |    </body>
> |</html>
> ```
>
> #### 3. Escape sequences
>
> After the content is re-indented, any *escape sequences* in the content are interpreted. A text block supports the same escape sequences as a string literal, such as `\n`, `\t`, `\'`, `\"`, and `\\`. See [section 3.10.6](https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-3.10.6) of the *The Java Language Specification* for the full list. Developers will have access to escape processing via `String::translateEscapes`, a new instance method.
>
> Interpreting escapes as the final step allows developers to use `\n`, `\f`, and `\r` for vertical formatting of a string without it affecting the translation of line terminators in step 1, and to use `\b` and `\t` for horizontal formatting of a string without it affecting the removal of incidental white space in step 2. For example, consider this text block that contains the `\r` escape sequence (CR):
>
> ```
> String html = """
>               <html>\r
>                   <body>\r
>                       <p>Hello, world</p>\r
>                   </body>\r
>               </html>\r
>               """;
> ```
>
> The CR escapes are not processed until after the line terminators have been normalized to LF. Using Unicode escapes to visualize LF (`\u000A`) and CR (`\u000D`), the result is:
>
> ```
> |<html>\u000D\u000A
> |    <body>\u000D\u000A
> |        <p>Hello, world</p>\u000D\u000A
> |    </body>\u000D\u000A
> |</html>\u000D\u000A
> ```
>
> Note that it is legal to use `"` freely inside a text block, even next to the opening or closing delimiter. For example:
>
> ```
> String story = """
>     "When I use a word," Humpty Dumpty said,
>     in rather a scornful tone, "it means just what I
>     choose it to mean - neither more nor less."
>     "The question is," said Alice, "whether you
>     can make words mean so many different things."
>     "The question is," said Humpty Dumpty,
>     "which is to be master - that's all."
>     """;
> ```
>
> However, sequences of three `"` characters require the escaping of at least one `"` to avoid mimicking the closing delimiter:
>
> ```
> String code = 
>     """
>     String text = \"""
>         A text block inside a text block
>     \""";
>     """;
> ```
>
> ### Concatenation of text blocks
>
> Text blocks can be used anywhere a string literal can be used. For example, text blocks and string literals may be concatenated interchangeably:
>
> ```
> String code = "public void print(Object o) {" +
>               """
>                   System.out.println(Objects.toString(o));
>               }
>               """;
> ```
>
> However, concatenation involving a text block can become rather clunky. Take this text block as a starting point:
>
> ```
> String code = """
>               public void print(Object o) {
>                   System.out.println(Objects.toString(o));
>               }
>               """;
> ```
>
> Suppose it needs to be changed so that the type of `o` comes from a variable. Using concatenation, the text block that contains the trailing code will need to start on a new line. Unfortunately, the straightforward insertion of a newline in the program, as below, will cause a long span of white space between the type and the text beginning `o` :
>
> ```
> String code = """
>               public void print(""" + type + """
>                                                  o) {
>                   System.out.println(Objects.toString(o));
>               }
>               """;
> ```
>
> The white space can be removed manually, but this hurts readability of the quoted code:
>
> ```
> String code = """
>               public void print(""" + type + """
>                o) {
>                   System.out.println(Objects.toString(o));
>               }
>               """;
> ```
>
> A cleaner alternative is to use `String::replace` or `String::format`, as follows:
>
> ```
> String code = """
>               public void print($type o) {
>                   System.out.println(Objects.toString(o));
>               }
>               """.replace("$type", type);
> String code = String.format("""
>               public void print(%s o) {
>                   System.out.println(Objects.toString(o));
>               }
>               """, type);
> ```
>
> Another alternative involves the introduction of a new instance method, `String::formatted`, which could be used as follows:
>
> ```
> String source = """
>                 public void print(%s object) {
>                     System.out.println(Objects.toString(object));
>                 }
>                 """.formatted(type);
> ```
>
> ### Additional Methods
>
> The following methods will be added to support text blocks;
>
> - `String::stripIndent()`: used to strip away incidental white space from the text block content
> - `String::translateEscapes()`: used to translate escape sequences
> - `String::formatted(Object... args)`: simplify value substitution in the text block

- 通过简化表达跨越多行源代码的字符串，同时避免常见情况下的转义序列，简化编写Java程序的任务。
- 增强Java程序中字符串的可读性，表示用非Java语言编写的代码。
- 通过规定任何新构造可以表达与字符串文字相同的字符串集，并解释相同的转义序列，并像字符串文字一样进行操作，支持从字符串文字进行迁移。

#### 2.3 Switch Expressions (Preview)

> ​	https://openjdk.java.net/jeps/354

> ### Arrow labels
>
> In addition to traditional "`case L :`" labels in a switch block, we propose a new simplified form, with "`case L ->`" labels. If a label is matched, then only the expression or statement to the right of the arrow is executed; there is no fall through. For example, given the following `switch` statement that uses the new form of labels:
>
> ```
> static void howMany(int k) {
>     switch (k) {
>         case 1  -> System.out.println("one");
>         case 2  -> System.out.println("two");
>         default -> System.out.println("many");
>     }
> }
> ```
>
> The following code:
>
> ```
> howMany(1);
> howMany(2);
> howMany(3);
> ```
>
> results in the following output:
>
> ```
> one
> two
> many
> ```
>
> ### Switch expressions
>
> We will extend the `switch` statement so it can be used as an expression. For example, the previous `howMany` method can be rewritten to use a `switch` expression, so it uses only a single `println`.
>
> ```
> static void howMany(int k) {
>     System.out.println(
>         switch (k) {
>             case  1 -> "one"
>             case  2 -> "two"
>             default -> "many"
>         }
>     );
> }
> ```
>
> In the common case, a `switch` expression will look like:
>
> ```
> T result = switch (arg) {
>     case L1 -> e1;
>     case L2 -> e2;
>     default -> e3;
> };
> ```
>
> A `switch` expression is a poly expression; if the target type is known, this type is pushed down into each arm. The type of a `switch` expression is its target type, if known; if not, a standalone type is computed by combining the types of each case arm.
>
> ### Yielding a value
>
> Most `switch` expressions will have a single expression to the right of the "`case L ->`" switch label. In the event that a full block is needed, we introduce a new `yield` statement to yield a value, which becomes the value of the enclosing `switch` expression.
>
> ```
> int j = switch (day) {
>     case MONDAY  -> 0;
>     case TUESDAY -> 1;
>     default      -> {
>         int k = day.toString().length();
>         int result = f(k);
>         yield result;
>     }
> };
> ```
>
> A `switch` expression can, like a `switch` statement, also use a traditional switch block with "`case L:`" switch labels (implying fall through semantics). In this case, values are yielded using the new `yield` statement:
>
> ```
> int result = switch (s) {
>     case "Foo": 
>         yield 1;
>     case "Bar":
>         yield 2;
>     default:
>         System.out.println("Neither Foo nor Bar, hmmm...");
>         yield 0;
> };
> ```
>
> The two statements, `break` (with or without a label) and `yield`, facilitate easy disambiguation between `switch` statements and `switch` expressions: a `switch` statement but not a `switch` expression can be the target of a `break` statement; and a `switch` expression but not a `switch` statement can be the target of a `yield` statement.
>
> > In the previous preview version of `switch` expressions, [JEP 325](https://openjdk.java.net/jeps/325), we proposed to add a new form of `break` statement with a value, which would be used to yield a value from a `switch` expression. In this version of `switch` expressions, this will be replaced with the new `yield` statement.
>
> ### Exhaustiveness
>
> The cases of a `switch` expression must be *exhaustive*; for all possible values there must be a matching switch label. (Obviously `switch` statements are not required to be exhaustive.)
>
> In practice this normally means that a `default` clause is required; however, in the case of an `enum` `switch` expression that covers all known constants, a `default` clause is inserted by the compiler to indicate that the `enum` definition has changed between compile-time and runtime. Relying on this implicit `default` clause insertion makes for more robust code; now when code is recompiled, the compiler checks that all cases are explicitly handled. Had the developer inserted an explicit `default` clause (as is the case today) a possible error will have been hidden.
>
> Furthermore, a `switch` expression must either complete normally with a value, or complete abruptly by throwing an exception. This has a number of consequences. First, the compiler checks that for every switch label, if it is matched then a value can be yielded.
>
> ```
> int i = switch (day) {
>     case MONDAY -> {
>         System.out.println("Monday"); 
>         // ERROR! Block doesn't contain a yield statement
>     }
>     default -> 1;
> };
> i = switch (day) {
>     case MONDAY, TUESDAY, WEDNESDAY: 
>         yield 0;
>     default: 
>         System.out.println("Second half of the week");
>         // ERROR! Group doesn't contain a yield statement
> };
> ```
>
> A further consequence is that the control statements, `break`, `yield`, `return` and `continue`, cannot jump through a `switch` expression, such as in the following:
>
> ```
> z: 
>     for (int i = 0; i < MAX_VALUE; ++i) {
>         int k = switch (e) { 
>             case 0:  
>                 yield 1;
>             case 1:
>                 yield 2;
>             default: 
>                 continue z; 
>                 // ERROR! Illegal jump through a switch expression 
>         };
>     ...
>     }
> ```

#### 2.4 动态CDS档案

> https://openjdk.java.net/jeps/350

##### 2.4.1目标

扩展[应用程序类 - 数据共享，](https://openjdk.java.net/jeps/310)以允许在Java应用程序执行结束时动态归档类。归档类将包括默认的基础层CDS存档中不存在的所有已加载的应用程序类和库类。

- 提高应用程序类 - 数据共享（[AppCDS](https://openjdk.java.net/jeps/310)）的可用性。消除了用户进行试运行以创建每个应用程序的类列表的需要。
- `-Xshare:dump`使用类列表由该选项启用的静态归档应继续工作。这包括内置类加载器和用户定义的类加载器的类。

##### 2.4.2 描述

> ### Supported archive configurations
>
> The following configurations will be supported at run time:
>
> - Static base archive (the default CDS archive) + dynamic archive — when both archives are mapped successfully
> - Static base archive only — when the dynamic archive cannot be mapped
>
> The dynamic archive currently requires the default CDS archive to be used as the base archive. If the base-layer archive cannot be mapped and used at run time then the top-layer dynamic archive is automatically disabled.
>
> ### Archiving classes at exit
>
> A shared archive is dynamically created when an application exits if the `-XX:ArchiveClassesAtExit` option is specified.
>
> The dynamically-generated archive is created on top of the default system archive packaged with the running JDK image. A separate top-layer archive file is generated for each application. The user can specify the filename of the dynamic archive name as the argument to the `-XX:ArchiveClassesAtExit` option. For example, the following command creates `hello.jsa`:
>
> ```
> % bin/java -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello
> ```
>
> To run the same application using this dynamic archive:
>
> ```
> % bin/java -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello
> ```
>
> ### Base-layer dependency
>
> The dynamically created top-layer archive depends upon the base-layer archive (i.e., it contains pointers to base-layer data), so the CRC values of the base archive header and all shared spaces are recorded in the top layer.
>
> At run time, when the dynamic archive is mapped in, all recorded CRC values are compared with the currently mapped base archive CRC values. If any of the CRC values do not match then the dynamic archive is disabled, without affecting the usage of the currently-mapped base archive.
>
> Using CRC values to check the base-archive dependency is more robust than using file name, size, and timestamp checks.
>
> ### Copying and relocating class metadata
>
> All loaded application classes and library classes (excluding the ones included in the base layer) are dynamically archived in the top layer. Currently, copying and relocating class metadata is done at the end of the application execution and before VM exit. Archived data is cleaned up in order to remove any non-shareable information.
>
> For a user-defined class loader the JVM needs to do extra copying before the class loader and its loaded classes are unloaded. The buffered data is copied into shared spaces with the rest of the dynamically-archived class metadata.
>
> ### Shared Spaces in dynamic archives
>
> The layout of the dynamic archive is similar to the existing static archive. Metadata is separated into the following four spaces. No “md” space needed.
>
> - **rw**: Readable/writable data
> - **ro**: Read-only data
> - **mc**: Trampoline
>
> The shared spaces are mapped individually at runtime. The “ro” space is mapped read-only to enable cross-process sharing.
>
> Memory Savings
>
> When you have multiple related processes running on the same host, you can improve memory sharing by using two levels of archives. For example, when you have these programs that share the same set of libraries:
>
> 2 processes running with "-cp:lib.jar:foo.jar FooApp"
>
> 4 processes running with "-cp:lib.jar:bar.jar BarApp"
>
> you can create a static archive (using a classlist) for only the classes in lib.jar (and other system classes used by these apps). Then, create two different dynamic archives, one for the "foo" app, and the other for the "bar" app.
>
> This way, the static archive can be shared across all 6 processes, and the dynamic archives can be shared among the processes running the same program.

###### 支持的归档配置

运行时将支持以下配置：

- 静态基本归档（默认CDS归档）+动态归档 - 成功映射两个归档时
- 仅限静态库存档 - 无法映射动态存档时

动态存档当前需要将默认CDS存档用作基本存档。如果无法在运行时映射和使用基础层归档，则会自动禁用顶层动态归档。

###### 在退出时归档课程

如果`-XX:ArchiveClassesAtExit`指定了选项，则在应用程序退出时动态创建共享存档。

动态生成的存档是在与正在运行的JDK映像一起打包的默认系统存档之上创建的。为每个应用程序生成单独的顶层归档文件。用户可以指定动态存档名称的文件名作为`-XX:ArchiveClassesAtExit`选项的参数。例如，以下命令创建`hello.jsa`：

```
% bin/java -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello
```

要使用此动态存档运行相同的应用程序：

```
% bin/java -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello
```

###### 基层依赖

动态创建的顶层归档取决于基础层归档（即，它包含指向基础层数据的指针），因此基本归档头和所有共享空间的CRC值记录在顶层。

在运行时，当映射动态归档时，将所有记录的CRC值与当前映射的基本归档CRC值进行比较。如果任何CRC值不匹配，则禁用动态存档，而不会影响当前映射的基本存档的使用。

使用CRC值检查基本归档依赖性比使用文件名，大小和时间戳检查更强大。

###### 复制和重定位类元数据

所有加载的应用程序类和库类（不包括基础层中包含的类）都在顶层动态存档。目前，复制和重定位类元数据是在应用程序执行结束时和VM退出之前完成的。清除存档数据以删除任何不可共享的信息。

对于用户定义的类加载器，JVM需要在卸载类加载器及其加载的类之前进行额外的复制。缓冲的数据将与其余动态存档的类元数据一起复制到共享空间中。

###### 动态档案中的共享空间

动态存档的布局类似于现有的静态存档。元数据分为以下四个空格。不需要“md”空间。

- **rw**：可读/可写数据
- **ro**：只读数据
- **mc**：蹦床

共享空间在运行时单独映射。“ro”空间以只读方式映射，以启用跨进程共享。

记忆储蓄

如果在同一主机上运行多个相关进程，则可以使用两个级别的存档来提高内存共享。例如，当您拥有共享同一组库的这些程序时：

使用“-cp：lib.jar：foo.jar FooApp”运行的2个进程

使用“-cp：lib.jar：bar.jar BarApp”运行的4个进程

您可以仅为lib.jar中的类（以及这些应用程序使用的其他系统类）创建静态存档（使用类列表）。然后，创建两个不同的动态档案，一个用于“foo”应用程序，另一个用于“bar”应用程序。

这样，静态存档可以在所有6个进程中共享，动态存档可以在运行相同程序的进程之间共享。